{"ast":null,"code":"// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\nimport { Log } from './Log.js';\nimport { OidcClient } from './OidcClient.js';\nimport { UserManagerSettings } from './UserManagerSettings.js';\nimport { User } from './User.js';\nimport { UserManagerEvents } from './UserManagerEvents.js';\nimport { SilentRenewService } from './SilentRenewService.js';\nimport { SessionMonitor } from './SessionMonitor.js';\nimport { SigninRequest } from \"./SigninRequest\";\nimport { TokenRevocationClient } from './TokenRevocationClient.js';\nimport { TokenClient } from './TokenClient.js';\nimport { JoseUtil } from './JoseUtil.js';\nexport class UserManager extends OidcClient {\n  constructor() {\n    let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let SilentRenewServiceCtor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SilentRenewService;\n    let SessionMonitorCtor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : SessionMonitor;\n    let TokenRevocationClientCtor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TokenRevocationClient;\n    let TokenClientCtor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : TokenClient;\n    let joseUtil = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : JoseUtil;\n\n    if (!(settings instanceof UserManagerSettings)) {\n      settings = new UserManagerSettings(settings);\n    }\n\n    super(settings);\n    this._events = new UserManagerEvents(settings);\n    this._silentRenewService = new SilentRenewServiceCtor(this); // order is important for the following properties; these services depend upon the events.\n\n    if (this.settings.automaticSilentRenew) {\n      Log.debug(\"UserManager.ctor: automaticSilentRenew is configured, setting up silent renew\");\n      this.startSilentRenew();\n    }\n\n    if (this.settings.monitorSession) {\n      Log.debug(\"UserManager.ctor: monitorSession is configured, setting up session monitor\");\n      this._sessionMonitor = new SessionMonitorCtor(this);\n    }\n\n    this._tokenRevocationClient = new TokenRevocationClientCtor(this._settings);\n    this._tokenClient = new TokenClientCtor(this._settings);\n    this._joseUtil = joseUtil;\n  }\n\n  get _redirectNavigator() {\n    return this.settings.redirectNavigator;\n  }\n\n  get _popupNavigator() {\n    return this.settings.popupNavigator;\n  }\n\n  get _iframeNavigator() {\n    return this.settings.iframeNavigator;\n  }\n\n  get _userStore() {\n    return this.settings.userStore;\n  }\n\n  get events() {\n    return this._events;\n  }\n\n  getUser() {\n    return this._loadUser().then(user => {\n      if (user) {\n        Log.info(\"UserManager.getUser: user loaded\");\n\n        this._events.load(user, false);\n\n        return user;\n      } else {\n        Log.info(\"UserManager.getUser: user not found in storage\");\n        return null;\n      }\n    });\n  }\n\n  removeUser() {\n    return this.storeUser(null).then(() => {\n      Log.info(\"UserManager.removeUser: user removed from storage\");\n\n      this._events.unload();\n    });\n  }\n\n  signinRedirect() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    args = Object.assign({}, args);\n    args.request_type = \"si:r\";\n    let navParams = {\n      useReplaceToNavigate: args.useReplaceToNavigate\n    };\n    return this._signinStart(args, this._redirectNavigator, navParams).then(() => {\n      Log.info(\"UserManager.signinRedirect: successful\");\n    });\n  }\n\n  signinRedirectCallback(url) {\n    return this._signinEnd(url || this._redirectNavigator.url).then(user => {\n      if (user.profile && user.profile.sub) {\n        Log.info(\"UserManager.signinRedirectCallback: successful, signed in sub: \", user.profile.sub);\n      } else {\n        Log.info(\"UserManager.signinRedirectCallback: no sub\");\n      }\n\n      return user;\n    });\n  }\n\n  signinPopup() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    args = Object.assign({}, args);\n    args.request_type = \"si:p\";\n    let url = args.redirect_uri || this.settings.popup_redirect_uri || this.settings.redirect_uri;\n\n    if (!url) {\n      Log.error(\"UserManager.signinPopup: No popup_redirect_uri or redirect_uri configured\");\n      return Promise.reject(new Error(\"No popup_redirect_uri or redirect_uri configured\"));\n    }\n\n    args.redirect_uri = url;\n    args.display = \"popup\";\n    return this._signin(args, this._popupNavigator, {\n      startUrl: url,\n      popupWindowFeatures: args.popupWindowFeatures || this.settings.popupWindowFeatures,\n      popupWindowTarget: args.popupWindowTarget || this.settings.popupWindowTarget\n    }).then(user => {\n      if (user) {\n        if (user.profile && user.profile.sub) {\n          Log.info(\"UserManager.signinPopup: signinPopup successful, signed in sub: \", user.profile.sub);\n        } else {\n          Log.info(\"UserManager.signinPopup: no sub\");\n        }\n      }\n\n      return user;\n    });\n  }\n\n  signinPopupCallback(url) {\n    return this._signinCallback(url, this._popupNavigator).then(user => {\n      if (user) {\n        if (user.profile && user.profile.sub) {\n          Log.info(\"UserManager.signinPopupCallback: successful, signed in sub: \", user.profile.sub);\n        } else {\n          Log.info(\"UserManager.signinPopupCallback: no sub\");\n        }\n      }\n\n      return user;\n    }).catch(err => {\n      Log.error(\"UserManager.signinPopupCallback error: \" + err && err.message);\n    });\n  }\n\n  signinSilent() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    args = Object.assign({}, args); // first determine if we have a refresh token, or need to use iframe\n\n    return this._loadUser().then(user => {\n      if (user && user.refresh_token) {\n        args.refresh_token = user.refresh_token;\n        return this._useRefreshToken(args);\n      } else {\n        args.request_type = \"si:s\";\n        args.id_token_hint = args.id_token_hint || this.settings.includeIdTokenInSilentRenew && user && user.id_token;\n\n        if (user && this._settings.validateSubOnSilentRenew) {\n          Log.debug(\"UserManager.signinSilent, subject prior to silent renew: \", user.profile.sub);\n          args.current_sub = user.profile.sub;\n        }\n\n        return this._signinSilentIframe(args);\n      }\n    });\n  }\n\n  _useRefreshToken() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._tokenClient.exchangeRefreshToken(args).then(result => {\n      if (!result) {\n        Log.error(\"UserManager._useRefreshToken: No response returned from token endpoint\");\n        return Promise.reject(\"No response returned from token endpoint\");\n      }\n\n      if (!result.access_token) {\n        Log.error(\"UserManager._useRefreshToken: No access token returned from token endpoint\");\n        return Promise.reject(\"No access token returned from token endpoint\");\n      }\n\n      return this._loadUser().then(user => {\n        if (user) {\n          let idTokenValidation = Promise.resolve();\n\n          if (result.id_token) {\n            idTokenValidation = this._validateIdTokenFromTokenRefreshToken(user.profile, result.id_token);\n          }\n\n          return idTokenValidation.then(() => {\n            Log.debug(\"UserManager._useRefreshToken: refresh token response success\");\n            user.id_token = result.id_token || user.id_token;\n            user.access_token = result.access_token;\n            user.refresh_token = result.refresh_token || user.refresh_token;\n            user.expires_in = result.expires_in;\n            return this.storeUser(user).then(() => {\n              this._events.load(user);\n\n              return user;\n            });\n          });\n        } else {\n          return null;\n        }\n      });\n    });\n  }\n\n  _validateIdTokenFromTokenRefreshToken(profile, id_token) {\n    return this._metadataService.getIssuer().then(issuer => {\n      return this.settings.getEpochTime().then(now => {\n        return this._joseUtil.validateJwtAttributes(id_token, issuer, this._settings.client_id, this._settings.clockSkew, now).then(payload => {\n          if (!payload) {\n            Log.error(\"UserManager._validateIdTokenFromTokenRefreshToken: Failed to validate id_token\");\n            return Promise.reject(new Error(\"Failed to validate id_token\"));\n          }\n\n          if (payload.sub !== profile.sub) {\n            Log.error(\"UserManager._validateIdTokenFromTokenRefreshToken: sub in id_token does not match current sub\");\n            return Promise.reject(new Error(\"sub in id_token does not match current sub\"));\n          }\n\n          if (payload.auth_time && payload.auth_time !== profile.auth_time) {\n            Log.error(\"UserManager._validateIdTokenFromTokenRefreshToken: auth_time in id_token does not match original auth_time\");\n            return Promise.reject(new Error(\"auth_time in id_token does not match original auth_time\"));\n          }\n\n          if (payload.azp && payload.azp !== profile.azp) {\n            Log.error(\"UserManager._validateIdTokenFromTokenRefreshToken: azp in id_token does not match original azp\");\n            return Promise.reject(new Error(\"azp in id_token does not match original azp\"));\n          }\n\n          if (!payload.azp && profile.azp) {\n            Log.error(\"UserManager._validateIdTokenFromTokenRefreshToken: azp not in id_token, but present in original id_token\");\n            return Promise.reject(new Error(\"azp not in id_token, but present in original id_token\"));\n          }\n        });\n      });\n    });\n  }\n\n  _signinSilentIframe() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let url = args.redirect_uri || this.settings.silent_redirect_uri || this.settings.redirect_uri;\n\n    if (!url) {\n      Log.error(\"UserManager.signinSilent: No silent_redirect_uri configured\");\n      return Promise.reject(new Error(\"No silent_redirect_uri configured\"));\n    }\n\n    args.redirect_uri = url;\n    args.prompt = args.prompt || \"none\";\n    return this._signin(args, this._iframeNavigator, {\n      startUrl: url,\n      silentRequestTimeout: args.silentRequestTimeout || this.settings.silentRequestTimeout\n    }).then(user => {\n      if (user) {\n        if (user.profile && user.profile.sub) {\n          Log.info(\"UserManager.signinSilent: successful, signed in sub: \", user.profile.sub);\n        } else {\n          Log.info(\"UserManager.signinSilent: no sub\");\n        }\n      }\n\n      return user;\n    });\n  }\n\n  signinSilentCallback(url) {\n    return this._signinCallback(url, this._iframeNavigator).then(user => {\n      if (user) {\n        if (user.profile && user.profile.sub) {\n          Log.info(\"UserManager.signinSilentCallback: successful, signed in sub: \", user.profile.sub);\n        } else {\n          Log.info(\"UserManager.signinSilentCallback: no sub\");\n        }\n      }\n\n      return user;\n    });\n  }\n\n  signinCallback(url) {\n    return this.readSigninResponseState(url).then(_ref => {\n      let {\n        state,\n        response\n      } = _ref;\n\n      if (state.request_type === \"si:r\") {\n        return this.signinRedirectCallback(url);\n      }\n\n      if (state.request_type === \"si:p\") {\n        return this.signinPopupCallback(url);\n      }\n\n      if (state.request_type === \"si:s\") {\n        return this.signinSilentCallback(url);\n      }\n\n      return Promise.reject(new Error(\"invalid response_type in state\"));\n    });\n  }\n\n  signoutCallback(url, keepOpen) {\n    return this.readSignoutResponseState(url).then(_ref2 => {\n      let {\n        state,\n        response\n      } = _ref2;\n\n      if (state) {\n        if (state.request_type === \"so:r\") {\n          return this.signoutRedirectCallback(url);\n        }\n\n        if (state.request_type === \"so:p\") {\n          return this.signoutPopupCallback(url, keepOpen);\n        }\n\n        return Promise.reject(new Error(\"invalid response_type in state\"));\n      }\n\n      return response;\n    });\n  }\n\n  querySessionStatus() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    args = Object.assign({}, args);\n    args.request_type = \"si:s\"; // this acts like a signin silent\n\n    let url = args.redirect_uri || this.settings.silent_redirect_uri || this.settings.redirect_uri;\n\n    if (!url) {\n      Log.error(\"UserManager.querySessionStatus: No silent_redirect_uri configured\");\n      return Promise.reject(new Error(\"No silent_redirect_uri configured\"));\n    }\n\n    args.redirect_uri = url;\n    args.prompt = \"none\";\n    args.response_type = args.response_type || this.settings.query_status_response_type;\n    args.scope = args.scope || \"openid\";\n    args.skipUserInfo = true;\n    return this._signinStart(args, this._iframeNavigator, {\n      startUrl: url,\n      silentRequestTimeout: args.silentRequestTimeout || this.settings.silentRequestTimeout\n    }).then(navResponse => {\n      return this.processSigninResponse(navResponse.url).then(signinResponse => {\n        Log.debug(\"UserManager.querySessionStatus: got signin response\");\n\n        if (signinResponse.session_state && signinResponse.profile.sub) {\n          Log.info(\"UserManager.querySessionStatus: querySessionStatus success for sub: \", signinResponse.profile.sub);\n          return {\n            session_state: signinResponse.session_state,\n            sub: signinResponse.profile.sub,\n            sid: signinResponse.profile.sid\n          };\n        } else {\n          Log.info(\"querySessionStatus successful, user not authenticated\");\n        }\n      }).catch(err => {\n        if (err.session_state && this.settings.monitorAnonymousSession) {\n          if (err.message == \"login_required\" || err.message == \"consent_required\" || err.message == \"interaction_required\" || err.message == \"account_selection_required\") {\n            Log.info(\"UserManager.querySessionStatus: querySessionStatus success for anonymous user\");\n            return {\n              session_state: err.session_state\n            };\n          }\n        }\n\n        throw err;\n      });\n    });\n  }\n\n  _signin(args, navigator) {\n    let navigatorParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this._signinStart(args, navigator, navigatorParams).then(navResponse => {\n      return this._signinEnd(navResponse.url, args);\n    });\n  }\n\n  _signinStart(args, navigator) {\n    let navigatorParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return navigator.prepare(navigatorParams).then(handle => {\n      Log.debug(\"UserManager._signinStart: got navigator window handle\");\n      return this.createSigninRequest(args).then(signinRequest => {\n        Log.debug(\"UserManager._signinStart: got signin request\");\n        navigatorParams.url = signinRequest.url;\n        navigatorParams.id = signinRequest.state.id;\n        return handle.navigate(navigatorParams);\n      }).catch(err => {\n        if (handle.close) {\n          Log.debug(\"UserManager._signinStart: Error after preparing navigator, closing navigator window\");\n          handle.close();\n        }\n\n        throw err;\n      });\n    });\n  }\n\n  _signinEnd(url) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.processSigninResponse(url).then(signinResponse => {\n      Log.debug(\"UserManager._signinEnd: got signin response\");\n      let user = new User(signinResponse);\n\n      if (args.current_sub) {\n        if (args.current_sub !== user.profile.sub) {\n          Log.debug(\"UserManager._signinEnd: current user does not match user returned from signin. sub from signin: \", user.profile.sub);\n          return Promise.reject(new Error(\"login_required\"));\n        } else {\n          Log.debug(\"UserManager._signinEnd: current user matches user returned from signin\");\n        }\n      }\n\n      return this.storeUser(user).then(() => {\n        Log.debug(\"UserManager._signinEnd: user stored\");\n\n        this._events.load(user);\n\n        return user;\n      });\n    });\n  }\n\n  _signinCallback(url, navigator) {\n    Log.debug(\"UserManager._signinCallback\");\n    let useQuery = this._settings.response_mode === \"query\" || !this._settings.response_mode && SigninRequest.isCode(this._settings.response_type);\n    let delimiter = useQuery ? \"?\" : \"#\";\n    return navigator.callback(url, undefined, delimiter);\n  }\n\n  signoutRedirect() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    args = Object.assign({}, args);\n    args.request_type = \"so:r\";\n    let postLogoutRedirectUri = args.post_logout_redirect_uri || this.settings.post_logout_redirect_uri;\n\n    if (postLogoutRedirectUri) {\n      args.post_logout_redirect_uri = postLogoutRedirectUri;\n    }\n\n    let navParams = {\n      useReplaceToNavigate: args.useReplaceToNavigate\n    };\n    return this._signoutStart(args, this._redirectNavigator, navParams).then(() => {\n      Log.info(\"UserManager.signoutRedirect: successful\");\n    });\n  }\n\n  signoutRedirectCallback(url) {\n    return this._signoutEnd(url || this._redirectNavigator.url).then(response => {\n      Log.info(\"UserManager.signoutRedirectCallback: successful\");\n      return response;\n    });\n  }\n\n  signoutPopup() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    args = Object.assign({}, args);\n    args.request_type = \"so:p\";\n    let url = args.post_logout_redirect_uri || this.settings.popup_post_logout_redirect_uri || this.settings.post_logout_redirect_uri;\n    args.post_logout_redirect_uri = url;\n    args.display = \"popup\";\n\n    if (args.post_logout_redirect_uri) {\n      // we're putting a dummy entry in here because we\n      // need a unique id from the state for notification\n      // to the parent window, which is necessary if we\n      // plan to return back to the client after signout\n      // and so we can close the popup after signout\n      args.state = args.state || {};\n    }\n\n    return this._signout(args, this._popupNavigator, {\n      startUrl: url,\n      popupWindowFeatures: args.popupWindowFeatures || this.settings.popupWindowFeatures,\n      popupWindowTarget: args.popupWindowTarget || this.settings.popupWindowTarget\n    }).then(() => {\n      Log.info(\"UserManager.signoutPopup: successful\");\n    });\n  }\n\n  signoutPopupCallback(url, keepOpen) {\n    if (typeof keepOpen === 'undefined' && typeof url === 'boolean') {\n      keepOpen = url;\n      url = null;\n    }\n\n    let delimiter = '?';\n    return this._popupNavigator.callback(url, keepOpen, delimiter).then(() => {\n      Log.info(\"UserManager.signoutPopupCallback: successful\");\n    });\n  }\n\n  _signout(args, navigator) {\n    let navigatorParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this._signoutStart(args, navigator, navigatorParams).then(navResponse => {\n      return this._signoutEnd(navResponse.url);\n    });\n  }\n\n  _signoutStart() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let navigator = arguments.length > 1 ? arguments[1] : undefined;\n    let navigatorParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return navigator.prepare(navigatorParams).then(handle => {\n      Log.debug(\"UserManager._signoutStart: got navigator window handle\");\n      return this._loadUser().then(user => {\n        Log.debug(\"UserManager._signoutStart: loaded current user from storage\");\n        var revokePromise = this._settings.revokeAccessTokenOnSignout ? this._revokeInternal(user) : Promise.resolve();\n        return revokePromise.then(() => {\n          var id_token = args.id_token_hint || user && user.id_token;\n\n          if (id_token) {\n            Log.debug(\"UserManager._signoutStart: Setting id_token into signout request\");\n            args.id_token_hint = id_token;\n          }\n\n          return this.removeUser().then(() => {\n            Log.debug(\"UserManager._signoutStart: user removed, creating signout request\");\n            return this.createSignoutRequest(args).then(signoutRequest => {\n              Log.debug(\"UserManager._signoutStart: got signout request\");\n              navigatorParams.url = signoutRequest.url;\n\n              if (signoutRequest.state) {\n                navigatorParams.id = signoutRequest.state.id;\n              }\n\n              return handle.navigate(navigatorParams);\n            });\n          });\n        });\n      }).catch(err => {\n        if (handle.close) {\n          Log.debug(\"UserManager._signoutStart: Error after preparing navigator, closing navigator window\");\n          handle.close();\n        }\n\n        throw err;\n      });\n    });\n  }\n\n  _signoutEnd(url) {\n    return this.processSignoutResponse(url).then(signoutResponse => {\n      Log.debug(\"UserManager._signoutEnd: got signout response\");\n      return signoutResponse;\n    });\n  }\n\n  revokeAccessToken() {\n    return this._loadUser().then(user => {\n      return this._revokeInternal(user, true).then(success => {\n        if (success) {\n          Log.debug(\"UserManager.revokeAccessToken: removing token properties from user and re-storing\");\n          user.access_token = null;\n          user.refresh_token = null;\n          user.expires_at = null;\n          user.token_type = null;\n          return this.storeUser(user).then(() => {\n            Log.debug(\"UserManager.revokeAccessToken: user stored\");\n\n            this._events.load(user);\n          });\n        }\n      });\n    }).then(() => {\n      Log.info(\"UserManager.revokeAccessToken: access token revoked successfully\");\n    });\n  }\n\n  _revokeInternal(user, required) {\n    if (user) {\n      var access_token = user.access_token;\n      var refresh_token = user.refresh_token;\n      return this._revokeAccessTokenInternal(access_token, required).then(atSuccess => {\n        return this._revokeRefreshTokenInternal(refresh_token, required).then(rtSuccess => {\n          if (!atSuccess && !rtSuccess) {\n            Log.debug(\"UserManager.revokeAccessToken: no need to revoke due to no token(s), or JWT format\");\n          }\n\n          return atSuccess || rtSuccess;\n        });\n      });\n    }\n\n    return Promise.resolve(false);\n  }\n\n  _revokeAccessTokenInternal(access_token, required) {\n    // check for JWT vs. reference token\n    if (!access_token || access_token.indexOf('.') >= 0) {\n      return Promise.resolve(false);\n    }\n\n    return this._tokenRevocationClient.revoke(access_token, required).then(() => true);\n  }\n\n  _revokeRefreshTokenInternal(refresh_token, required) {\n    if (!refresh_token) {\n      return Promise.resolve(false);\n    }\n\n    return this._tokenRevocationClient.revoke(refresh_token, required, \"refresh_token\").then(() => true);\n  }\n\n  startSilentRenew() {\n    this._silentRenewService.start();\n  }\n\n  stopSilentRenew() {\n    this._silentRenewService.stop();\n  }\n\n  get _userStoreKey() {\n    return `user:${this.settings.authority}:${this.settings.client_id}`;\n  }\n\n  _loadUser() {\n    return this._userStore.get(this._userStoreKey).then(storageString => {\n      if (storageString) {\n        Log.debug(\"UserManager._loadUser: user storageString loaded\");\n        return User.fromStorageString(storageString);\n      }\n\n      Log.debug(\"UserManager._loadUser: no user storageString\");\n      return null;\n    });\n  }\n\n  storeUser(user) {\n    if (user) {\n      Log.debug(\"UserManager.storeUser: storing user\");\n      var storageString = user.toStorageString();\n      return this._userStore.set(this._userStoreKey, storageString);\n    } else {\n      Log.debug(\"storeUser.storeUser: removing user\");\n      return this._userStore.remove(this._userStoreKey);\n    }\n  }\n\n}","map":{"version":3,"names":["Log","OidcClient","UserManagerSettings","User","UserManagerEvents","SilentRenewService","SessionMonitor","SigninRequest","TokenRevocationClient","TokenClient","JoseUtil","UserManager","constructor","settings","SilentRenewServiceCtor","SessionMonitorCtor","TokenRevocationClientCtor","TokenClientCtor","joseUtil","_events","_silentRenewService","automaticSilentRenew","debug","startSilentRenew","monitorSession","_sessionMonitor","_tokenRevocationClient","_settings","_tokenClient","_joseUtil","_redirectNavigator","redirectNavigator","_popupNavigator","popupNavigator","_iframeNavigator","iframeNavigator","_userStore","userStore","events","getUser","_loadUser","then","user","info","load","removeUser","storeUser","unload","signinRedirect","args","Object","assign","request_type","navParams","useReplaceToNavigate","_signinStart","signinRedirectCallback","url","_signinEnd","profile","sub","signinPopup","redirect_uri","popup_redirect_uri","error","Promise","reject","Error","display","_signin","startUrl","popupWindowFeatures","popupWindowTarget","signinPopupCallback","_signinCallback","catch","err","message","signinSilent","refresh_token","_useRefreshToken","id_token_hint","includeIdTokenInSilentRenew","id_token","validateSubOnSilentRenew","current_sub","_signinSilentIframe","exchangeRefreshToken","result","access_token","idTokenValidation","resolve","_validateIdTokenFromTokenRefreshToken","expires_in","_metadataService","getIssuer","issuer","getEpochTime","now","validateJwtAttributes","client_id","clockSkew","payload","auth_time","azp","silent_redirect_uri","prompt","silentRequestTimeout","signinSilentCallback","signinCallback","readSigninResponseState","state","response","signoutCallback","keepOpen","readSignoutResponseState","signoutRedirectCallback","signoutPopupCallback","querySessionStatus","response_type","query_status_response_type","scope","skipUserInfo","navResponse","processSigninResponse","signinResponse","session_state","sid","monitorAnonymousSession","navigator","navigatorParams","prepare","handle","createSigninRequest","signinRequest","id","navigate","close","useQuery","response_mode","isCode","delimiter","callback","undefined","signoutRedirect","postLogoutRedirectUri","post_logout_redirect_uri","_signoutStart","_signoutEnd","signoutPopup","popup_post_logout_redirect_uri","_signout","revokePromise","revokeAccessTokenOnSignout","_revokeInternal","createSignoutRequest","signoutRequest","processSignoutResponse","signoutResponse","revokeAccessToken","success","expires_at","token_type","required","_revokeAccessTokenInternal","atSuccess","_revokeRefreshTokenInternal","rtSuccess","indexOf","revoke","start","stopSilentRenew","stop","_userStoreKey","authority","get","storageString","fromStorageString","toStorageString","set","remove"],"sources":["C:/Users/theoj/Desktop/WebbProject-Yr3-React18/ClientApp/node_modules/oidc-client/src/UserManager.js"],"sourcesContent":["// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\r\n\r\nimport { Log } from './Log.js';\r\nimport { OidcClient } from './OidcClient.js';\r\nimport { UserManagerSettings } from './UserManagerSettings.js';\r\nimport { User } from './User.js';\r\nimport { UserManagerEvents } from './UserManagerEvents.js';\r\nimport { SilentRenewService } from './SilentRenewService.js';\r\nimport { SessionMonitor } from './SessionMonitor.js';\r\nimport { SigninRequest } from \"./SigninRequest\";\r\nimport { TokenRevocationClient } from './TokenRevocationClient.js';\r\nimport { TokenClient } from './TokenClient.js';\r\nimport { JoseUtil } from './JoseUtil.js';\r\n\r\n\r\nexport class UserManager extends OidcClient {\r\n    constructor(settings = {},\r\n        SilentRenewServiceCtor = SilentRenewService,\r\n        SessionMonitorCtor = SessionMonitor,\r\n        TokenRevocationClientCtor = TokenRevocationClient,\r\n        TokenClientCtor = TokenClient,\r\n        joseUtil = JoseUtil\r\n    ) {\r\n\r\n        if (!(settings instanceof UserManagerSettings)) {\r\n            settings = new UserManagerSettings(settings);\r\n        }\r\n        super(settings);\r\n\r\n        this._events = new UserManagerEvents(settings);\r\n        this._silentRenewService = new SilentRenewServiceCtor(this);\r\n\r\n        // order is important for the following properties; these services depend upon the events.\r\n        if (this.settings.automaticSilentRenew) {\r\n            Log.debug(\"UserManager.ctor: automaticSilentRenew is configured, setting up silent renew\");\r\n            this.startSilentRenew();\r\n        }\r\n\r\n        if (this.settings.monitorSession) {\r\n            Log.debug(\"UserManager.ctor: monitorSession is configured, setting up session monitor\");\r\n            this._sessionMonitor = new SessionMonitorCtor(this);\r\n        }\r\n\r\n        this._tokenRevocationClient = new TokenRevocationClientCtor(this._settings);\r\n        this._tokenClient = new TokenClientCtor(this._settings);\r\n        this._joseUtil = joseUtil;\r\n    }\r\n\r\n    get _redirectNavigator() {\r\n        return this.settings.redirectNavigator;\r\n    }\r\n    get _popupNavigator() {\r\n        return this.settings.popupNavigator;\r\n    }\r\n    get _iframeNavigator() {\r\n        return this.settings.iframeNavigator;\r\n    }\r\n    get _userStore() {\r\n        return this.settings.userStore;\r\n    }\r\n\r\n    get events() {\r\n        return this._events;\r\n    }\r\n\r\n    getUser() {\r\n        return this._loadUser().then(user => {\r\n            if (user) {\r\n                Log.info(\"UserManager.getUser: user loaded\");\r\n\r\n                this._events.load(user, false);\r\n\r\n                return user;\r\n            }\r\n            else {\r\n                Log.info(\"UserManager.getUser: user not found in storage\");\r\n                return null;\r\n            }\r\n        });\r\n    }\r\n\r\n    removeUser() {\r\n        return this.storeUser(null).then(() => {\r\n            Log.info(\"UserManager.removeUser: user removed from storage\");\r\n            this._events.unload();\r\n        });\r\n    }\r\n\r\n    signinRedirect(args = {}) {\r\n        args = Object.assign({}, args);\r\n\r\n        args.request_type = \"si:r\";\r\n        let navParams = {\r\n            useReplaceToNavigate : args.useReplaceToNavigate\r\n        };\r\n        return this._signinStart(args, this._redirectNavigator, navParams).then(()=>{\r\n            Log.info(\"UserManager.signinRedirect: successful\");\r\n        });\r\n    }\r\n    signinRedirectCallback(url) {\r\n        return this._signinEnd(url || this._redirectNavigator.url).then(user => {\r\n            if (user.profile && user.profile.sub) {\r\n                Log.info(\"UserManager.signinRedirectCallback: successful, signed in sub: \", user.profile.sub);\r\n            }\r\n            else {\r\n                Log.info(\"UserManager.signinRedirectCallback: no sub\");\r\n            }\r\n\r\n            return user;\r\n        });\r\n    }\r\n\r\n    signinPopup(args = {}) {\r\n        args = Object.assign({}, args);\r\n\r\n        args.request_type = \"si:p\";\r\n        let url = args.redirect_uri || this.settings.popup_redirect_uri || this.settings.redirect_uri;\r\n        if (!url) {\r\n            Log.error(\"UserManager.signinPopup: No popup_redirect_uri or redirect_uri configured\");\r\n            return Promise.reject(new Error(\"No popup_redirect_uri or redirect_uri configured\"));\r\n        }\r\n\r\n        args.redirect_uri = url;\r\n        args.display = \"popup\";\r\n\r\n        return this._signin(args, this._popupNavigator, {\r\n            startUrl: url,\r\n            popupWindowFeatures: args.popupWindowFeatures || this.settings.popupWindowFeatures,\r\n            popupWindowTarget: args.popupWindowTarget || this.settings.popupWindowTarget\r\n        }).then(user => {\r\n            if (user) {\r\n                if (user.profile && user.profile.sub) {\r\n                    Log.info(\"UserManager.signinPopup: signinPopup successful, signed in sub: \", user.profile.sub);\r\n                }\r\n                else {\r\n                    Log.info(\"UserManager.signinPopup: no sub\");\r\n                }\r\n            }\r\n\r\n            return user;\r\n        });\r\n    }\r\n    signinPopupCallback(url) {\r\n        return this._signinCallback(url, this._popupNavigator).then(user => {\r\n            if (user) {\r\n                if (user.profile && user.profile.sub) {\r\n                    Log.info(\"UserManager.signinPopupCallback: successful, signed in sub: \", user.profile.sub);\r\n                }\r\n                else {\r\n                    Log.info(\"UserManager.signinPopupCallback: no sub\");\r\n                }\r\n            }\r\n\r\n            return user;\r\n        }).catch(err=>{\r\n            Log.error(\"UserManager.signinPopupCallback error: \" + err && err.message);\r\n        });\r\n    }\r\n\r\n    signinSilent(args = {}) {\r\n        args = Object.assign({}, args);\r\n\r\n        // first determine if we have a refresh token, or need to use iframe\r\n        return this._loadUser().then(user => {\r\n            if (user && user.refresh_token) {\r\n                args.refresh_token = user.refresh_token;\r\n                return this._useRefreshToken(args);\r\n            }\r\n            else {\r\n                args.request_type = \"si:s\";\r\n                args.id_token_hint = args.id_token_hint || (this.settings.includeIdTokenInSilentRenew && user && user.id_token);\r\n                if (user && this._settings.validateSubOnSilentRenew) {\r\n                    Log.debug(\"UserManager.signinSilent, subject prior to silent renew: \", user.profile.sub);\r\n                    args.current_sub = user.profile.sub;\r\n                }\r\n                return this._signinSilentIframe(args);\r\n            }\r\n        });\r\n    }\r\n\r\n    _useRefreshToken(args = {}) {\r\n        return this._tokenClient.exchangeRefreshToken(args).then(result => {\r\n            if (!result) {\r\n                Log.error(\"UserManager._useRefreshToken: No response returned from token endpoint\");\r\n                return Promise.reject(\"No response returned from token endpoint\");\r\n            }\r\n            if (!result.access_token) {\r\n                Log.error(\"UserManager._useRefreshToken: No access token returned from token endpoint\");\r\n                return Promise.reject(\"No access token returned from token endpoint\");\r\n            }\r\n\r\n            return this._loadUser().then(user => {\r\n                if (user) {\r\n                    let idTokenValidation = Promise.resolve();\r\n                    if (result.id_token) {\r\n                        idTokenValidation = this._validateIdTokenFromTokenRefreshToken(user.profile, result.id_token);\r\n                    }\r\n\r\n                    return idTokenValidation.then(() => {\r\n                        Log.debug(\"UserManager._useRefreshToken: refresh token response success\");\r\n                        user.id_token = result.id_token || user.id_token;\r\n                        user.access_token = result.access_token;\r\n                        user.refresh_token = result.refresh_token || user.refresh_token;\r\n                        user.expires_in = result.expires_in;\r\n\r\n                        return this.storeUser(user).then(()=>{\r\n                            this._events.load(user);\r\n                            return user;\r\n                        });\r\n                    });\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    _validateIdTokenFromTokenRefreshToken(profile, id_token) {\r\n        return this._metadataService.getIssuer().then(issuer => {\r\n            return this.settings.getEpochTime().then(now => {\r\n                return this._joseUtil.validateJwtAttributes(id_token, issuer, this._settings.client_id, this._settings.clockSkew, now).then(payload => {\r\n                    if (!payload) {\r\n                        Log.error(\"UserManager._validateIdTokenFromTokenRefreshToken: Failed to validate id_token\");\r\n                        return Promise.reject(new Error(\"Failed to validate id_token\"));\r\n                    }\r\n                    if (payload.sub !== profile.sub) {\r\n                        Log.error(\"UserManager._validateIdTokenFromTokenRefreshToken: sub in id_token does not match current sub\");\r\n                        return Promise.reject(new Error(\"sub in id_token does not match current sub\"));\r\n                    }\r\n                    if (payload.auth_time && payload.auth_time !== profile.auth_time) {\r\n                        Log.error(\"UserManager._validateIdTokenFromTokenRefreshToken: auth_time in id_token does not match original auth_time\");\r\n                        return Promise.reject(new Error(\"auth_time in id_token does not match original auth_time\"));\r\n                    }\r\n                    if (payload.azp && payload.azp !== profile.azp) {\r\n                        Log.error(\"UserManager._validateIdTokenFromTokenRefreshToken: azp in id_token does not match original azp\");\r\n                        return Promise.reject(new Error(\"azp in id_token does not match original azp\"));\r\n                    }\r\n                    if (!payload.azp && profile.azp) {\r\n                        Log.error(\"UserManager._validateIdTokenFromTokenRefreshToken: azp not in id_token, but present in original id_token\");\r\n                        return Promise.reject(new Error(\"azp not in id_token, but present in original id_token\"));\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    }\r\n    \r\n    _signinSilentIframe(args = {}) {\r\n        let url = args.redirect_uri || this.settings.silent_redirect_uri || this.settings.redirect_uri;\r\n        if (!url) {\r\n            Log.error(\"UserManager.signinSilent: No silent_redirect_uri configured\");\r\n            return Promise.reject(new Error(\"No silent_redirect_uri configured\"));\r\n        }\r\n\r\n        args.redirect_uri = url;\r\n        args.prompt = args.prompt || \"none\";\r\n\r\n        return this._signin(args, this._iframeNavigator, {\r\n            startUrl: url,\r\n            silentRequestTimeout: args.silentRequestTimeout || this.settings.silentRequestTimeout\r\n        }).then(user => {\r\n            if (user) {\r\n                if (user.profile && user.profile.sub) {\r\n                    Log.info(\"UserManager.signinSilent: successful, signed in sub: \", user.profile.sub);\r\n                }\r\n                else {\r\n                    Log.info(\"UserManager.signinSilent: no sub\");\r\n                }\r\n            }\r\n\r\n            return user;\r\n        });\r\n    }\r\n\r\n    signinSilentCallback(url) {\r\n        return this._signinCallback(url, this._iframeNavigator).then(user => {\r\n            if (user) {\r\n                if (user.profile && user.profile.sub) {\r\n                    Log.info(\"UserManager.signinSilentCallback: successful, signed in sub: \", user.profile.sub);\r\n                }\r\n                else {\r\n                    Log.info(\"UserManager.signinSilentCallback: no sub\");\r\n                }\r\n            }\r\n\r\n            return user;\r\n        });\r\n    }\r\n\r\n    signinCallback(url) {\r\n        return this.readSigninResponseState(url).then(({state, response}) => {\r\n            if (state.request_type === \"si:r\") {\r\n                return this.signinRedirectCallback(url);\r\n            }\r\n            if (state.request_type === \"si:p\") {\r\n                return this.signinPopupCallback(url);\r\n            }\r\n            if (state.request_type === \"si:s\") {\r\n                return this.signinSilentCallback(url);\r\n            }\r\n            return Promise.reject(new Error(\"invalid response_type in state\"));\r\n        });\r\n    }\r\n\r\n    signoutCallback(url, keepOpen) {\r\n        return this.readSignoutResponseState(url).then(({state, response}) => {\r\n            if (state) {\r\n                if (state.request_type === \"so:r\") {\r\n                    return this.signoutRedirectCallback(url);\r\n                }\r\n                if (state.request_type === \"so:p\") {\r\n                    return this.signoutPopupCallback(url, keepOpen);\r\n                }\r\n                return Promise.reject(new Error(\"invalid response_type in state\"));\r\n            }\r\n            return response;\r\n        });\r\n    }\r\n\r\n    querySessionStatus(args = {}) {\r\n        args = Object.assign({}, args);\r\n\r\n        args.request_type = \"si:s\"; // this acts like a signin silent\r\n        let url = args.redirect_uri || this.settings.silent_redirect_uri || this.settings.redirect_uri;\r\n        if (!url) {\r\n            Log.error(\"UserManager.querySessionStatus: No silent_redirect_uri configured\");\r\n            return Promise.reject(new Error(\"No silent_redirect_uri configured\"));\r\n        }\r\n\r\n        args.redirect_uri = url;\r\n        args.prompt = \"none\";\r\n        args.response_type = args.response_type || this.settings.query_status_response_type;\r\n        args.scope = args.scope || \"openid\";\r\n        args.skipUserInfo = true;\r\n\r\n        return this._signinStart(args, this._iframeNavigator, {\r\n            startUrl: url,\r\n            silentRequestTimeout: args.silentRequestTimeout || this.settings.silentRequestTimeout\r\n        }).then(navResponse => {\r\n            return this.processSigninResponse(navResponse.url).then(signinResponse => {\r\n                Log.debug(\"UserManager.querySessionStatus: got signin response\");\r\n\r\n                if (signinResponse.session_state && signinResponse.profile.sub) {\r\n                    Log.info(\"UserManager.querySessionStatus: querySessionStatus success for sub: \",  signinResponse.profile.sub);\r\n                    return {\r\n                        session_state: signinResponse.session_state,\r\n                        sub: signinResponse.profile.sub,\r\n                        sid: signinResponse.profile.sid\r\n                    };\r\n                }\r\n                else {\r\n                    Log.info(\"querySessionStatus successful, user not authenticated\");\r\n                }\r\n            })\r\n            .catch(err => {\r\n                if (err.session_state && this.settings.monitorAnonymousSession) {\r\n                    if (err.message == \"login_required\" || \r\n                        err.message == \"consent_required\" || \r\n                        err.message == \"interaction_required\" || \r\n                        err.message == \"account_selection_required\"\r\n                    ) {\r\n                        Log.info(\"UserManager.querySessionStatus: querySessionStatus success for anonymous user\");\r\n                        return {\r\n                            session_state: err.session_state\r\n                        };\r\n                    }\r\n                }\r\n\r\n                throw err;\r\n            });\r\n        });\r\n    }\r\n\r\n    _signin(args, navigator, navigatorParams = {}) {\r\n        return this._signinStart(args, navigator, navigatorParams).then(navResponse => {\r\n            return this._signinEnd(navResponse.url, args);\r\n        });\r\n    }\r\n    _signinStart(args, navigator, navigatorParams = {}) {\r\n\r\n        return navigator.prepare(navigatorParams).then(handle => {\r\n            Log.debug(\"UserManager._signinStart: got navigator window handle\");\r\n\r\n            return this.createSigninRequest(args).then(signinRequest => {\r\n                Log.debug(\"UserManager._signinStart: got signin request\");\r\n\r\n                navigatorParams.url = signinRequest.url;\r\n                navigatorParams.id = signinRequest.state.id;\r\n\r\n                return handle.navigate(navigatorParams);\r\n            }).catch(err => {\r\n                if (handle.close) {\r\n                    Log.debug(\"UserManager._signinStart: Error after preparing navigator, closing navigator window\");\r\n                    handle.close();\r\n                }\r\n                throw err;\r\n            });\r\n        });\r\n    }\r\n    _signinEnd(url, args = {}) {\r\n        return this.processSigninResponse(url).then(signinResponse => {\r\n            Log.debug(\"UserManager._signinEnd: got signin response\");\r\n\r\n            let user = new User(signinResponse);\r\n\r\n            if (args.current_sub) {\r\n                if (args.current_sub !== user.profile.sub) {\r\n                    Log.debug(\"UserManager._signinEnd: current user does not match user returned from signin. sub from signin: \", user.profile.sub);\r\n                    return Promise.reject(new Error(\"login_required\"));\r\n                }\r\n                else {\r\n                    Log.debug(\"UserManager._signinEnd: current user matches user returned from signin\");\r\n                }\r\n            }\r\n\r\n            return this.storeUser(user).then(() => {\r\n                Log.debug(\"UserManager._signinEnd: user stored\");\r\n\r\n                this._events.load(user);\r\n\r\n                return user;\r\n            });\r\n        });\r\n    }\r\n    _signinCallback(url, navigator) {\r\n        Log.debug(\"UserManager._signinCallback\");\r\n        let useQuery = this._settings.response_mode === \"query\" || (!this._settings.response_mode && SigninRequest.isCode(this._settings.response_type));\r\n        let delimiter = useQuery ? \"?\" : \"#\";\r\n        return navigator.callback(url, undefined, delimiter);\r\n    }\r\n\r\n    signoutRedirect(args = {}) {\r\n        args = Object.assign({}, args);\r\n\r\n        args.request_type = \"so:r\";\r\n        let postLogoutRedirectUri = args.post_logout_redirect_uri || this.settings.post_logout_redirect_uri;\r\n        if (postLogoutRedirectUri){\r\n            args.post_logout_redirect_uri = postLogoutRedirectUri;\r\n        }\r\n        let navParams = {\r\n            useReplaceToNavigate : args.useReplaceToNavigate\r\n        };\r\n        return this._signoutStart(args, this._redirectNavigator, navParams).then(()=>{\r\n            Log.info(\"UserManager.signoutRedirect: successful\");\r\n        });\r\n    }\r\n    signoutRedirectCallback(url) {\r\n        return this._signoutEnd(url || this._redirectNavigator.url).then(response=>{\r\n            Log.info(\"UserManager.signoutRedirectCallback: successful\");\r\n            return response;\r\n        });\r\n    }\r\n\r\n    signoutPopup(args = {}) {\r\n        args = Object.assign({}, args);\r\n\r\n        args.request_type = \"so:p\";\r\n        let url = args.post_logout_redirect_uri || this.settings.popup_post_logout_redirect_uri || this.settings.post_logout_redirect_uri;\r\n        args.post_logout_redirect_uri = url;\r\n        args.display = \"popup\";\r\n        if (args.post_logout_redirect_uri){\r\n            // we're putting a dummy entry in here because we\r\n            // need a unique id from the state for notification\r\n            // to the parent window, which is necessary if we\r\n            // plan to return back to the client after signout\r\n            // and so we can close the popup after signout\r\n            args.state = args.state || {};\r\n        }\r\n\r\n        return this._signout(args, this._popupNavigator, {\r\n            startUrl: url,\r\n            popupWindowFeatures: args.popupWindowFeatures || this.settings.popupWindowFeatures,\r\n            popupWindowTarget: args.popupWindowTarget || this.settings.popupWindowTarget\r\n        }).then(() => {\r\n            Log.info(\"UserManager.signoutPopup: successful\");\r\n        });\r\n    }\r\n    signoutPopupCallback(url, keepOpen) {\r\n        if (typeof(keepOpen) === 'undefined' && typeof(url) === 'boolean') {\r\n            keepOpen = url;\r\n            url = null;\r\n        }\r\n\r\n        let delimiter = '?';\r\n        return this._popupNavigator.callback(url, keepOpen, delimiter).then(() => {\r\n            Log.info(\"UserManager.signoutPopupCallback: successful\");\r\n        });\r\n    }\r\n\r\n    _signout(args, navigator, navigatorParams = {}) {\r\n        return this._signoutStart(args, navigator, navigatorParams).then(navResponse => {\r\n            return this._signoutEnd(navResponse.url);\r\n        });\r\n    }\r\n    _signoutStart(args = {}, navigator, navigatorParams = {}) {\r\n        return navigator.prepare(navigatorParams).then(handle => {\r\n            Log.debug(\"UserManager._signoutStart: got navigator window handle\");\r\n\r\n            return this._loadUser().then(user => {\r\n                Log.debug(\"UserManager._signoutStart: loaded current user from storage\");\r\n\r\n                var revokePromise = this._settings.revokeAccessTokenOnSignout ? this._revokeInternal(user) : Promise.resolve();\r\n                return revokePromise.then(() => {\r\n\r\n                    var id_token = args.id_token_hint || user && user.id_token;\r\n                    if (id_token) {\r\n                        Log.debug(\"UserManager._signoutStart: Setting id_token into signout request\");\r\n                        args.id_token_hint = id_token;\r\n                    }\r\n\r\n                    return this.removeUser().then(() => {\r\n                        Log.debug(\"UserManager._signoutStart: user removed, creating signout request\");\r\n\r\n                        return this.createSignoutRequest(args).then(signoutRequest => {\r\n                            Log.debug(\"UserManager._signoutStart: got signout request\");\r\n\r\n                            navigatorParams.url = signoutRequest.url;\r\n                            if (signoutRequest.state) {\r\n                                navigatorParams.id = signoutRequest.state.id;\r\n                            }\r\n                            return handle.navigate(navigatorParams);\r\n                        });\r\n                    });\r\n                });\r\n            }).catch(err => {\r\n                if (handle.close) {\r\n                    Log.debug(\"UserManager._signoutStart: Error after preparing navigator, closing navigator window\");\r\n                    handle.close();\r\n                }\r\n                throw err;\r\n            });\r\n        });\r\n    }\r\n    _signoutEnd(url) {\r\n        return this.processSignoutResponse(url).then(signoutResponse => {\r\n            Log.debug(\"UserManager._signoutEnd: got signout response\");\r\n\r\n            return signoutResponse;\r\n        });\r\n    }\r\n\r\n    revokeAccessToken() {\r\n        return this._loadUser().then(user => {\r\n            return this._revokeInternal(user, true).then(success => {\r\n                if (success) {\r\n                    Log.debug(\"UserManager.revokeAccessToken: removing token properties from user and re-storing\");\r\n\r\n                    user.access_token = null;\r\n                    user.refresh_token = null;\r\n                    user.expires_at = null;\r\n                    user.token_type = null;\r\n\r\n                    return this.storeUser(user).then(() => {\r\n                        Log.debug(\"UserManager.revokeAccessToken: user stored\");\r\n                        this._events.load(user);\r\n                    });\r\n                }\r\n            });\r\n        }).then(()=>{\r\n            Log.info(\"UserManager.revokeAccessToken: access token revoked successfully\");\r\n        });\r\n    }\r\n\r\n    _revokeInternal(user, required) {\r\n        if (user) {\r\n            var access_token = user.access_token;\r\n            var refresh_token = user.refresh_token;\r\n\r\n            return this._revokeAccessTokenInternal(access_token, required)\r\n                .then(atSuccess => {\r\n                    return this._revokeRefreshTokenInternal(refresh_token, required)\r\n                        .then(rtSuccess => {\r\n                            if (!atSuccess && !rtSuccess) {\r\n                                Log.debug(\"UserManager.revokeAccessToken: no need to revoke due to no token(s), or JWT format\");\r\n                            }\r\n                            \r\n                            return atSuccess || rtSuccess;\r\n                        });\r\n                });\r\n        }\r\n\r\n        return Promise.resolve(false);\r\n    }\r\n\r\n    _revokeAccessTokenInternal(access_token, required) {\r\n        // check for JWT vs. reference token\r\n        if (!access_token || access_token.indexOf('.') >= 0) {\r\n            return Promise.resolve(false);\r\n        }\r\n\r\n        return this._tokenRevocationClient.revoke(access_token, required).then(() => true);\r\n    }\r\n\r\n    _revokeRefreshTokenInternal(refresh_token, required) {\r\n        if (!refresh_token) {\r\n            return Promise.resolve(false);\r\n        }\r\n\r\n        return this._tokenRevocationClient.revoke(refresh_token, required, \"refresh_token\").then(() => true);\r\n    }\r\n\r\n    startSilentRenew() {\r\n        this._silentRenewService.start();\r\n    }\r\n\r\n    stopSilentRenew() {\r\n        this._silentRenewService.stop();\r\n    }\r\n\r\n    get _userStoreKey() {\r\n        return `user:${this.settings.authority}:${this.settings.client_id}`;\r\n    }\r\n\r\n    _loadUser() {\r\n        return this._userStore.get(this._userStoreKey).then(storageString => {\r\n            if (storageString) {\r\n                Log.debug(\"UserManager._loadUser: user storageString loaded\");\r\n                return User.fromStorageString(storageString);\r\n            }\r\n\r\n            Log.debug(\"UserManager._loadUser: no user storageString\");\r\n            return null;\r\n        });\r\n    }\r\n\r\n    storeUser(user) {\r\n        if (user) {\r\n            Log.debug(\"UserManager.storeUser: storing user\");\r\n\r\n            var storageString = user.toStorageString();\r\n            return this._userStore.set(this._userStoreKey, storageString);\r\n        }\r\n        else {\r\n            Log.debug(\"storeUser.storeUser: removing user\");\r\n            return this._userStore.remove(this._userStoreKey);\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}