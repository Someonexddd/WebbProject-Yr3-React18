{"ast":null,"code":"// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\nimport { Log } from './Log.js';\nimport { MetadataService } from './MetadataService.js';\nimport { UserInfoService } from './UserInfoService.js';\nimport { TokenClient } from './TokenClient.js';\nimport { ErrorResponse } from './ErrorResponse.js';\nimport { JoseUtil } from './JoseUtil.js';\nconst ProtocolClaims = [\"nonce\", \"at_hash\", \"iat\", \"nbf\", \"exp\", \"aud\", \"iss\", \"c_hash\"];\nexport class ResponseValidator {\n  constructor(settings) {\n    let MetadataServiceCtor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MetadataService;\n    let UserInfoServiceCtor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : UserInfoService;\n    let joseUtil = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : JoseUtil;\n    let TokenClientCtor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : TokenClient;\n\n    if (!settings) {\n      Log.error(\"ResponseValidator.ctor: No settings passed to ResponseValidator\");\n      throw new Error(\"settings\");\n    }\n\n    this._settings = settings;\n    this._metadataService = new MetadataServiceCtor(this._settings);\n    this._userInfoService = new UserInfoServiceCtor(this._settings);\n    this._joseUtil = joseUtil;\n    this._tokenClient = new TokenClientCtor(this._settings);\n  }\n\n  validateSigninResponse(state, response) {\n    Log.debug(\"ResponseValidator.validateSigninResponse\");\n    return this._processSigninParams(state, response).then(response => {\n      Log.debug(\"ResponseValidator.validateSigninResponse: state processed\");\n      return this._validateTokens(state, response).then(response => {\n        Log.debug(\"ResponseValidator.validateSigninResponse: tokens validated\");\n        return this._processClaims(state, response).then(response => {\n          Log.debug(\"ResponseValidator.validateSigninResponse: claims processed\");\n          return response;\n        });\n      });\n    });\n  }\n\n  validateSignoutResponse(state, response) {\n    if (state.id !== response.state) {\n      Log.error(\"ResponseValidator.validateSignoutResponse: State does not match\");\n      return Promise.reject(new Error(\"State does not match\"));\n    } // now that we know the state matches, take the stored data\n    // and set it into the response so callers can get their state\n    // this is important for both success & error outcomes\n\n\n    Log.debug(\"ResponseValidator.validateSignoutResponse: state validated\");\n    response.state = state.data;\n\n    if (response.error) {\n      Log.warn(\"ResponseValidator.validateSignoutResponse: Response was error\", response.error);\n      return Promise.reject(new ErrorResponse(response));\n    }\n\n    return Promise.resolve(response);\n  }\n\n  _processSigninParams(state, response) {\n    if (state.id !== response.state) {\n      Log.error(\"ResponseValidator._processSigninParams: State does not match\");\n      return Promise.reject(new Error(\"State does not match\"));\n    }\n\n    if (!state.client_id) {\n      Log.error(\"ResponseValidator._processSigninParams: No client_id on state\");\n      return Promise.reject(new Error(\"No client_id on state\"));\n    }\n\n    if (!state.authority) {\n      Log.error(\"ResponseValidator._processSigninParams: No authority on state\");\n      return Promise.reject(new Error(\"No authority on state\"));\n    } // this allows the authority to be loaded from the signin state\n\n\n    if (!this._settings.authority) {\n      this._settings.authority = state.authority;\n    } // ensure we're using the correct authority if the authority is not loaded from signin state\n    else if (this._settings.authority && this._settings.authority !== state.authority) {\n      Log.error(\"ResponseValidator._processSigninParams: authority mismatch on settings vs. signin state\");\n      return Promise.reject(new Error(\"authority mismatch on settings vs. signin state\"));\n    } // this allows the client_id to be loaded from the signin state\n\n\n    if (!this._settings.client_id) {\n      this._settings.client_id = state.client_id;\n    } // ensure we're using the correct client_id if the client_id is not loaded from signin state\n    else if (this._settings.client_id && this._settings.client_id !== state.client_id) {\n      Log.error(\"ResponseValidator._processSigninParams: client_id mismatch on settings vs. signin state\");\n      return Promise.reject(new Error(\"client_id mismatch on settings vs. signin state\"));\n    } // now that we know the state matches, take the stored data\n    // and set it into the response so callers can get their state\n    // this is important for both success & error outcomes\n\n\n    Log.debug(\"ResponseValidator._processSigninParams: state validated\");\n    response.state = state.data;\n\n    if (response.error) {\n      Log.warn(\"ResponseValidator._processSigninParams: Response was error\", response.error);\n      return Promise.reject(new ErrorResponse(response));\n    }\n\n    if (state.nonce && !response.id_token) {\n      Log.error(\"ResponseValidator._processSigninParams: Expecting id_token in response\");\n      return Promise.reject(new Error(\"No id_token in response\"));\n    }\n\n    if (!state.nonce && response.id_token) {\n      Log.error(\"ResponseValidator._processSigninParams: Not expecting id_token in response\");\n      return Promise.reject(new Error(\"Unexpected id_token in response\"));\n    }\n\n    if (state.code_verifier && !response.code) {\n      Log.error(\"ResponseValidator._processSigninParams: Expecting code in response\");\n      return Promise.reject(new Error(\"No code in response\"));\n    }\n\n    if (!state.code_verifier && response.code) {\n      Log.error(\"ResponseValidator._processSigninParams: Not expecting code in response\");\n      return Promise.reject(new Error(\"Unexpected code in response\"));\n    }\n\n    if (!response.scope) {\n      // if there's no scope on the response, then assume all scopes granted (per-spec) and copy over scopes from original request\n      response.scope = state.scope;\n    }\n\n    return Promise.resolve(response);\n  }\n\n  _processClaims(state, response) {\n    if (response.isOpenIdConnect) {\n      Log.debug(\"ResponseValidator._processClaims: response is OIDC, processing claims\");\n      response.profile = this._filterProtocolClaims(response.profile);\n\n      if (state.skipUserInfo !== true && this._settings.loadUserInfo && response.access_token) {\n        Log.debug(\"ResponseValidator._processClaims: loading user info\");\n        return this._userInfoService.getClaims(response.access_token).then(claims => {\n          Log.debug(\"ResponseValidator._processClaims: user info claims received from user info endpoint\");\n\n          if (claims.sub !== response.profile.sub) {\n            Log.error(\"ResponseValidator._processClaims: sub from user info endpoint does not match sub in id_token\");\n            return Promise.reject(new Error(\"sub from user info endpoint does not match sub in id_token\"));\n          }\n\n          response.profile = this._mergeClaims(response.profile, claims);\n          Log.debug(\"ResponseValidator._processClaims: user info claims received, updated profile:\", response.profile);\n          return response;\n        });\n      } else {\n        Log.debug(\"ResponseValidator._processClaims: not loading user info\");\n      }\n    } else {\n      Log.debug(\"ResponseValidator._processClaims: response is not OIDC, not processing claims\");\n    }\n\n    return Promise.resolve(response);\n  }\n\n  _mergeClaims(claims1, claims2) {\n    var result = Object.assign({}, claims1);\n\n    for (let name in claims2) {\n      var values = claims2[name];\n\n      if (!Array.isArray(values)) {\n        values = [values];\n      }\n\n      for (let i = 0; i < values.length; i++) {\n        let value = values[i];\n\n        if (!result[name]) {\n          result[name] = value;\n        } else if (Array.isArray(result[name])) {\n          if (result[name].indexOf(value) < 0) {\n            result[name].push(value);\n          }\n        } else if (result[name] !== value) {\n          if (typeof value === 'object' && this._settings.mergeClaims) {\n            result[name] = this._mergeClaims(result[name], value);\n          } else {\n            result[name] = [result[name], value];\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  _filterProtocolClaims(claims) {\n    Log.debug(\"ResponseValidator._filterProtocolClaims, incoming claims:\", claims);\n    var result = Object.assign({}, claims);\n\n    if (this._settings._filterProtocolClaims) {\n      ProtocolClaims.forEach(type => {\n        delete result[type];\n      });\n      Log.debug(\"ResponseValidator._filterProtocolClaims: protocol claims filtered\", result);\n    } else {\n      Log.debug(\"ResponseValidator._filterProtocolClaims: protocol claims not filtered\");\n    }\n\n    return result;\n  }\n\n  _validateTokens(state, response) {\n    if (response.code) {\n      Log.debug(\"ResponseValidator._validateTokens: Validating code\");\n      return this._processCode(state, response);\n    }\n\n    if (response.id_token) {\n      if (response.access_token) {\n        Log.debug(\"ResponseValidator._validateTokens: Validating id_token and access_token\");\n        return this._validateIdTokenAndAccessToken(state, response);\n      }\n\n      Log.debug(\"ResponseValidator._validateTokens: Validating id_token\");\n      return this._validateIdToken(state, response);\n    }\n\n    Log.debug(\"ResponseValidator._validateTokens: No code to process or id_token to validate\");\n    return Promise.resolve(response);\n  }\n\n  _processCode(state, response) {\n    var request = {\n      client_id: state.client_id,\n      client_secret: state.client_secret,\n      code: response.code,\n      redirect_uri: state.redirect_uri,\n      code_verifier: state.code_verifier\n    };\n\n    if (state.extraTokenParams && typeof state.extraTokenParams === 'object') {\n      Object.assign(request, state.extraTokenParams);\n    }\n\n    return this._tokenClient.exchangeCode(request).then(tokenResponse => {\n      for (var key in tokenResponse) {\n        response[key] = tokenResponse[key];\n      }\n\n      if (response.id_token) {\n        Log.debug(\"ResponseValidator._processCode: token response successful, processing id_token\");\n        return this._validateIdTokenAttributes(state, response);\n      } else {\n        Log.debug(\"ResponseValidator._processCode: token response successful, returning response\");\n      }\n\n      return response;\n    });\n  }\n\n  _validateIdTokenAttributes(state, response) {\n    return this._metadataService.getIssuer().then(issuer => {\n      let audience = state.client_id;\n      let clockSkewInSeconds = this._settings.clockSkew;\n      Log.debug(\"ResponseValidator._validateIdTokenAttributes: Validaing JWT attributes; using clock skew (in seconds) of: \", clockSkewInSeconds);\n      return this._settings.getEpochTime().then(now => {\n        return this._joseUtil.validateJwtAttributes(response.id_token, issuer, audience, clockSkewInSeconds, now).then(payload => {\n          if (state.nonce && state.nonce !== payload.nonce) {\n            Log.error(\"ResponseValidator._validateIdTokenAttributes: Invalid nonce in id_token\");\n            return Promise.reject(new Error(\"Invalid nonce in id_token\"));\n          }\n\n          if (!payload.sub) {\n            Log.error(\"ResponseValidator._validateIdTokenAttributes: No sub present in id_token\");\n            return Promise.reject(new Error(\"No sub present in id_token\"));\n          }\n\n          response.profile = payload;\n          return response;\n        });\n      });\n    });\n  }\n\n  _validateIdTokenAndAccessToken(state, response) {\n    return this._validateIdToken(state, response).then(response => {\n      return this._validateAccessToken(response);\n    });\n  }\n\n  _getSigningKeyForJwt(jwt) {\n    return this._metadataService.getSigningKeys().then(keys => {\n      const kid = jwt.header.kid;\n\n      if (!keys) {\n        Log.error(\"ResponseValidator._validateIdToken: No signing keys from metadata\");\n        return Promise.reject(new Error(\"No signing keys from metadata\"));\n      }\n\n      Log.debug(\"ResponseValidator._validateIdToken: Received signing keys\");\n      let key;\n\n      if (!kid) {\n        keys = this._filterByAlg(keys, jwt.header.alg);\n\n        if (keys.length > 1) {\n          Log.error(\"ResponseValidator._validateIdToken: No kid found in id_token and more than one key found in metadata\");\n          return Promise.reject(new Error(\"No kid found in id_token and more than one key found in metadata\"));\n        } else {\n          // kid is mandatory only when there are multiple keys in the referenced JWK Set document\n          // see http://openid.net/specs/openid-connect-core-1_0.html#Signing\n          key = keys[0];\n        }\n      } else {\n        key = keys.filter(key => {\n          return key.kid === kid;\n        })[0];\n      }\n\n      return Promise.resolve(key);\n    });\n  }\n\n  _getSigningKeyForJwtWithSingleRetry(jwt) {\n    return this._getSigningKeyForJwt(jwt).then(key => {\n      // Refreshing signingKeys if no suitable verification key is present for given jwt header.\n      if (!key) {\n        // set to undefined, to trigger network call to jwks_uri.\n        this._metadataService.resetSigningKeys();\n\n        return this._getSigningKeyForJwt(jwt);\n      } else {\n        return Promise.resolve(key);\n      }\n    });\n  }\n\n  _validateIdToken(state, response) {\n    if (!state.nonce) {\n      Log.error(\"ResponseValidator._validateIdToken: No nonce on state\");\n      return Promise.reject(new Error(\"No nonce on state\"));\n    }\n\n    let jwt = this._joseUtil.parseJwt(response.id_token);\n\n    if (!jwt || !jwt.header || !jwt.payload) {\n      Log.error(\"ResponseValidator._validateIdToken: Failed to parse id_token\", jwt);\n      return Promise.reject(new Error(\"Failed to parse id_token\"));\n    }\n\n    if (state.nonce !== jwt.payload.nonce) {\n      Log.error(\"ResponseValidator._validateIdToken: Invalid nonce in id_token\");\n      return Promise.reject(new Error(\"Invalid nonce in id_token\"));\n    }\n\n    return this._metadataService.getIssuer().then(issuer => {\n      Log.debug(\"ResponseValidator._validateIdToken: Received issuer\");\n      return this._getSigningKeyForJwtWithSingleRetry(jwt).then(key => {\n        if (!key) {\n          Log.error(\"ResponseValidator._validateIdToken: No key matching kid or alg found in signing keys\");\n          return Promise.reject(new Error(\"No key matching kid or alg found in signing keys\"));\n        }\n\n        let audience = state.client_id;\n        let clockSkewInSeconds = this._settings.clockSkew;\n        Log.debug(\"ResponseValidator._validateIdToken: Validaing JWT; using clock skew (in seconds) of: \", clockSkewInSeconds);\n        return this._joseUtil.validateJwt(response.id_token, key, issuer, audience, clockSkewInSeconds).then(() => {\n          Log.debug(\"ResponseValidator._validateIdToken: JWT validation successful\");\n\n          if (!jwt.payload.sub) {\n            Log.error(\"ResponseValidator._validateIdToken: No sub present in id_token\");\n            return Promise.reject(new Error(\"No sub present in id_token\"));\n          }\n\n          response.profile = jwt.payload;\n          return response;\n        });\n      });\n    });\n  }\n\n  _filterByAlg(keys, alg) {\n    var kty = null;\n\n    if (alg.startsWith(\"RS\")) {\n      kty = \"RSA\";\n    } else if (alg.startsWith(\"PS\")) {\n      kty = \"PS\";\n    } else if (alg.startsWith(\"ES\")) {\n      kty = \"EC\";\n    } else {\n      Log.debug(\"ResponseValidator._filterByAlg: alg not supported: \", alg);\n      return [];\n    }\n\n    Log.debug(\"ResponseValidator._filterByAlg: Looking for keys that match kty: \", kty);\n    keys = keys.filter(key => {\n      return key.kty === kty;\n    });\n    Log.debug(\"ResponseValidator._filterByAlg: Number of keys that match kty: \", kty, keys.length);\n    return keys;\n  }\n\n  _validateAccessToken(response) {\n    if (!response.profile) {\n      Log.error(\"ResponseValidator._validateAccessToken: No profile loaded from id_token\");\n      return Promise.reject(new Error(\"No profile loaded from id_token\"));\n    }\n\n    if (!response.profile.at_hash) {\n      Log.error(\"ResponseValidator._validateAccessToken: No at_hash in id_token\");\n      return Promise.reject(new Error(\"No at_hash in id_token\"));\n    }\n\n    if (!response.id_token) {\n      Log.error(\"ResponseValidator._validateAccessToken: No id_token\");\n      return Promise.reject(new Error(\"No id_token\"));\n    }\n\n    let jwt = this._joseUtil.parseJwt(response.id_token);\n\n    if (!jwt || !jwt.header) {\n      Log.error(\"ResponseValidator._validateAccessToken: Failed to parse id_token\", jwt);\n      return Promise.reject(new Error(\"Failed to parse id_token\"));\n    }\n\n    var hashAlg = jwt.header.alg;\n\n    if (!hashAlg || hashAlg.length !== 5) {\n      Log.error(\"ResponseValidator._validateAccessToken: Unsupported alg:\", hashAlg);\n      return Promise.reject(new Error(\"Unsupported alg: \" + hashAlg));\n    }\n\n    var hashBits = hashAlg.substr(2, 3);\n\n    if (!hashBits) {\n      Log.error(\"ResponseValidator._validateAccessToken: Unsupported alg:\", hashAlg, hashBits);\n      return Promise.reject(new Error(\"Unsupported alg: \" + hashAlg));\n    }\n\n    hashBits = parseInt(hashBits);\n\n    if (hashBits !== 256 && hashBits !== 384 && hashBits !== 512) {\n      Log.error(\"ResponseValidator._validateAccessToken: Unsupported alg:\", hashAlg, hashBits);\n      return Promise.reject(new Error(\"Unsupported alg: \" + hashAlg));\n    }\n\n    let sha = \"sha\" + hashBits;\n\n    var hash = this._joseUtil.hashString(response.access_token, sha);\n\n    if (!hash) {\n      Log.error(\"ResponseValidator._validateAccessToken: access_token hash failed:\", sha);\n      return Promise.reject(new Error(\"Failed to validate at_hash\"));\n    }\n\n    var left = hash.substr(0, hash.length / 2);\n\n    var left_b64u = this._joseUtil.hexToBase64Url(left);\n\n    if (left_b64u !== response.profile.at_hash) {\n      Log.error(\"ResponseValidator._validateAccessToken: Failed to validate at_hash\", left_b64u, response.profile.at_hash);\n      return Promise.reject(new Error(\"Failed to validate at_hash\"));\n    }\n\n    Log.debug(\"ResponseValidator._validateAccessToken: success\");\n    return Promise.resolve(response);\n  }\n\n}","map":{"version":3,"names":["Log","MetadataService","UserInfoService","TokenClient","ErrorResponse","JoseUtil","ProtocolClaims","ResponseValidator","constructor","settings","MetadataServiceCtor","UserInfoServiceCtor","joseUtil","TokenClientCtor","error","Error","_settings","_metadataService","_userInfoService","_joseUtil","_tokenClient","validateSigninResponse","state","response","debug","_processSigninParams","then","_validateTokens","_processClaims","validateSignoutResponse","id","Promise","reject","data","warn","resolve","client_id","authority","nonce","id_token","code_verifier","code","scope","isOpenIdConnect","profile","_filterProtocolClaims","skipUserInfo","loadUserInfo","access_token","getClaims","claims","sub","_mergeClaims","claims1","claims2","result","Object","assign","name","values","Array","isArray","i","length","value","indexOf","push","mergeClaims","forEach","type","_processCode","_validateIdTokenAndAccessToken","_validateIdToken","request","client_secret","redirect_uri","extraTokenParams","exchangeCode","tokenResponse","key","_validateIdTokenAttributes","getIssuer","issuer","audience","clockSkewInSeconds","clockSkew","getEpochTime","now","validateJwtAttributes","payload","_validateAccessToken","_getSigningKeyForJwt","jwt","getSigningKeys","keys","kid","header","_filterByAlg","alg","filter","_getSigningKeyForJwtWithSingleRetry","resetSigningKeys","parseJwt","validateJwt","kty","startsWith","at_hash","hashAlg","hashBits","substr","parseInt","sha","hash","hashString","left","left_b64u","hexToBase64Url"],"sources":["C:/Users/theoj/Desktop/WebbProject-Yr3-React18/ClientApp/node_modules/oidc-client/src/ResponseValidator.js"],"sourcesContent":["// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\r\n\r\nimport { Log } from './Log.js';\r\nimport { MetadataService } from './MetadataService.js';\r\nimport { UserInfoService } from './UserInfoService.js';\r\nimport { TokenClient } from './TokenClient.js';\r\nimport { ErrorResponse } from './ErrorResponse.js';\r\nimport { JoseUtil } from './JoseUtil.js';\r\n\r\nconst ProtocolClaims = [\"nonce\", \"at_hash\", \"iat\", \"nbf\", \"exp\", \"aud\", \"iss\", \"c_hash\"];\r\n\r\nexport class ResponseValidator {\r\n\r\n    constructor(settings, \r\n        MetadataServiceCtor = MetadataService,\r\n        UserInfoServiceCtor = UserInfoService, \r\n        joseUtil = JoseUtil,\r\n        TokenClientCtor = TokenClient) {\r\n        if (!settings) {\r\n            Log.error(\"ResponseValidator.ctor: No settings passed to ResponseValidator\");\r\n            throw new Error(\"settings\");\r\n        }\r\n\r\n        this._settings = settings;\r\n        this._metadataService = new MetadataServiceCtor(this._settings);\r\n        this._userInfoService = new UserInfoServiceCtor(this._settings);\r\n        this._joseUtil = joseUtil;\r\n        this._tokenClient = new TokenClientCtor(this._settings);\r\n    }\r\n\r\n    validateSigninResponse(state, response) {\r\n        Log.debug(\"ResponseValidator.validateSigninResponse\");\r\n\r\n        return this._processSigninParams(state, response).then(response => {\r\n            Log.debug(\"ResponseValidator.validateSigninResponse: state processed\");\r\n            return this._validateTokens(state, response).then(response => {\r\n                Log.debug(\"ResponseValidator.validateSigninResponse: tokens validated\");\r\n                return this._processClaims(state, response).then(response => {\r\n                    Log.debug(\"ResponseValidator.validateSigninResponse: claims processed\");\r\n                    return response;\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    validateSignoutResponse(state, response) {\r\n        if (state.id !== response.state) {\r\n            Log.error(\"ResponseValidator.validateSignoutResponse: State does not match\");\r\n            return Promise.reject(new Error(\"State does not match\"));\r\n        }\r\n\r\n        // now that we know the state matches, take the stored data\r\n        // and set it into the response so callers can get their state\r\n        // this is important for both success & error outcomes\r\n        Log.debug(\"ResponseValidator.validateSignoutResponse: state validated\");\r\n        response.state = state.data;\r\n\r\n        if (response.error) {\r\n            Log.warn(\"ResponseValidator.validateSignoutResponse: Response was error\", response.error);\r\n            return Promise.reject(new ErrorResponse(response));\r\n        }\r\n\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    _processSigninParams(state, response) {\r\n        if (state.id !== response.state) {\r\n            Log.error(\"ResponseValidator._processSigninParams: State does not match\");\r\n            return Promise.reject(new Error(\"State does not match\"));\r\n        }\r\n\r\n        if (!state.client_id) {\r\n            Log.error(\"ResponseValidator._processSigninParams: No client_id on state\");\r\n            return Promise.reject(new Error(\"No client_id on state\"));\r\n        }\r\n\r\n        if (!state.authority) {\r\n            Log.error(\"ResponseValidator._processSigninParams: No authority on state\");\r\n            return Promise.reject(new Error(\"No authority on state\"));\r\n        }\r\n\r\n        // this allows the authority to be loaded from the signin state\r\n        if (!this._settings.authority) {\r\n            this._settings.authority = state.authority;\r\n        }\r\n        // ensure we're using the correct authority if the authority is not loaded from signin state\r\n        else if (this._settings.authority && this._settings.authority !== state.authority) {\r\n            Log.error(\"ResponseValidator._processSigninParams: authority mismatch on settings vs. signin state\");\r\n            return Promise.reject(new Error(\"authority mismatch on settings vs. signin state\"));\r\n        }\r\n        // this allows the client_id to be loaded from the signin state\r\n        if (!this._settings.client_id) {\r\n            this._settings.client_id = state.client_id;\r\n        }\r\n        // ensure we're using the correct client_id if the client_id is not loaded from signin state\r\n        else if (this._settings.client_id && this._settings.client_id !== state.client_id) {\r\n            Log.error(\"ResponseValidator._processSigninParams: client_id mismatch on settings vs. signin state\");\r\n            return Promise.reject(new Error(\"client_id mismatch on settings vs. signin state\"));\r\n        }\r\n\r\n        // now that we know the state matches, take the stored data\r\n        // and set it into the response so callers can get their state\r\n        // this is important for both success & error outcomes\r\n        Log.debug(\"ResponseValidator._processSigninParams: state validated\");\r\n        response.state = state.data;\r\n\r\n        if (response.error) {\r\n            Log.warn(\"ResponseValidator._processSigninParams: Response was error\", response.error);\r\n            return Promise.reject(new ErrorResponse(response));\r\n        }\r\n\r\n        if (state.nonce && !response.id_token) {\r\n            Log.error(\"ResponseValidator._processSigninParams: Expecting id_token in response\");\r\n            return Promise.reject(new Error(\"No id_token in response\"));\r\n        }\r\n\r\n        if (!state.nonce && response.id_token) {\r\n            Log.error(\"ResponseValidator._processSigninParams: Not expecting id_token in response\");\r\n            return Promise.reject(new Error(\"Unexpected id_token in response\"));\r\n        }\r\n\r\n        if (state.code_verifier && !response.code) {\r\n            Log.error(\"ResponseValidator._processSigninParams: Expecting code in response\");\r\n            return Promise.reject(new Error(\"No code in response\"));\r\n        }\r\n\r\n        if (!state.code_verifier && response.code) {\r\n            Log.error(\"ResponseValidator._processSigninParams: Not expecting code in response\");\r\n            return Promise.reject(new Error(\"Unexpected code in response\"));\r\n        }\r\n\r\n        if (!response.scope) {\r\n            // if there's no scope on the response, then assume all scopes granted (per-spec) and copy over scopes from original request\r\n            response.scope = state.scope;\r\n        }\r\n\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    _processClaims(state, response) {\r\n        if (response.isOpenIdConnect) {\r\n            Log.debug(\"ResponseValidator._processClaims: response is OIDC, processing claims\");\r\n\r\n            response.profile = this._filterProtocolClaims(response.profile);\r\n\r\n            if (state.skipUserInfo !== true && this._settings.loadUserInfo && response.access_token) {\r\n                Log.debug(\"ResponseValidator._processClaims: loading user info\");\r\n\r\n                return this._userInfoService.getClaims(response.access_token).then(claims => {\r\n                    Log.debug(\"ResponseValidator._processClaims: user info claims received from user info endpoint\");\r\n\r\n                    if (claims.sub !== response.profile.sub) {\r\n                        Log.error(\"ResponseValidator._processClaims: sub from user info endpoint does not match sub in id_token\");\r\n                        return Promise.reject(new Error(\"sub from user info endpoint does not match sub in id_token\"));\r\n                    }\r\n\r\n                    response.profile = this._mergeClaims(response.profile, claims);\r\n                    Log.debug(\"ResponseValidator._processClaims: user info claims received, updated profile:\", response.profile);\r\n\r\n                    return response;\r\n                });\r\n            }\r\n            else {\r\n                Log.debug(\"ResponseValidator._processClaims: not loading user info\");\r\n            }\r\n        }\r\n        else {\r\n            Log.debug(\"ResponseValidator._processClaims: response is not OIDC, not processing claims\");\r\n        }\r\n\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    _mergeClaims(claims1, claims2) {\r\n        var result = Object.assign({}, claims1);\r\n\r\n        for (let name in claims2) {\r\n            var values = claims2[name];\r\n            if (!Array.isArray(values)) {\r\n                values = [values];\r\n            }\r\n\r\n            for (let i = 0; i < values.length; i++) {\r\n                let value = values[i];\r\n                if (!result[name]) {\r\n                    result[name] = value;\r\n                }\r\n                else if (Array.isArray(result[name])) {\r\n                    if (result[name].indexOf(value) < 0) {\r\n                        result[name].push(value);\r\n                    }\r\n                }\r\n                else if (result[name] !== value) {\r\n                    if (typeof value === 'object' && this._settings.mergeClaims) {\r\n                        result[name] = this._mergeClaims(result[name], value);\r\n                    }\r\n                    else {\r\n                        result[name] = [result[name], value];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    _filterProtocolClaims(claims) {\r\n        Log.debug(\"ResponseValidator._filterProtocolClaims, incoming claims:\", claims);\r\n\r\n        var result = Object.assign({}, claims);\r\n\r\n        if (this._settings._filterProtocolClaims) {\r\n            ProtocolClaims.forEach(type => {\r\n                delete result[type];\r\n            });\r\n\r\n            Log.debug(\"ResponseValidator._filterProtocolClaims: protocol claims filtered\", result);\r\n        }\r\n        else {\r\n            Log.debug(\"ResponseValidator._filterProtocolClaims: protocol claims not filtered\")\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    _validateTokens(state, response) {\r\n        if (response.code) {\r\n            Log.debug(\"ResponseValidator._validateTokens: Validating code\");\r\n            return this._processCode(state, response);\r\n        }\r\n\r\n        if (response.id_token) {\r\n            if (response.access_token) {\r\n                Log.debug(\"ResponseValidator._validateTokens: Validating id_token and access_token\");\r\n                return this._validateIdTokenAndAccessToken(state, response);\r\n            }\r\n\r\n            Log.debug(\"ResponseValidator._validateTokens: Validating id_token\");\r\n            return this._validateIdToken(state, response);\r\n        }\r\n\r\n        Log.debug(\"ResponseValidator._validateTokens: No code to process or id_token to validate\");\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    _processCode(state, response) {\r\n        var request = {\r\n            client_id: state.client_id,\r\n            client_secret: state.client_secret,\r\n            code : response.code,\r\n            redirect_uri: state.redirect_uri,\r\n            code_verifier: state.code_verifier\r\n        };\r\n\r\n        if (state.extraTokenParams && typeof(state.extraTokenParams) === 'object') {\r\n            Object.assign(request, state.extraTokenParams);\r\n        }\r\n        \r\n        return this._tokenClient.exchangeCode(request).then(tokenResponse => {\r\n            \r\n            for(var key in tokenResponse) {\r\n                response[key] = tokenResponse[key];\r\n            }\r\n\r\n            if (response.id_token) {\r\n                Log.debug(\"ResponseValidator._processCode: token response successful, processing id_token\");\r\n                return this._validateIdTokenAttributes(state, response);\r\n            }\r\n            else {\r\n                Log.debug(\"ResponseValidator._processCode: token response successful, returning response\");\r\n            }\r\n            \r\n            return response;\r\n        });\r\n    }\r\n\r\n    _validateIdTokenAttributes(state, response) {\r\n        return this._metadataService.getIssuer().then(issuer => {\r\n\r\n            let audience = state.client_id;\r\n            let clockSkewInSeconds = this._settings.clockSkew;\r\n            Log.debug(\"ResponseValidator._validateIdTokenAttributes: Validaing JWT attributes; using clock skew (in seconds) of: \", clockSkewInSeconds);\r\n\r\n            return this._settings.getEpochTime().then(now => {\r\n                return this._joseUtil.validateJwtAttributes(response.id_token, issuer, audience, clockSkewInSeconds, now).then(payload => {\r\n                \r\n                    if (state.nonce && state.nonce !== payload.nonce) {\r\n                        Log.error(\"ResponseValidator._validateIdTokenAttributes: Invalid nonce in id_token\");\r\n                        return Promise.reject(new Error(\"Invalid nonce in id_token\"));\r\n                    }\r\n    \r\n                    if (!payload.sub) {\r\n                        Log.error(\"ResponseValidator._validateIdTokenAttributes: No sub present in id_token\");\r\n                        return Promise.reject(new Error(\"No sub present in id_token\"));\r\n                    }\r\n    \r\n                    response.profile = payload;\r\n                    return response;\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    _validateIdTokenAndAccessToken(state, response) {\r\n        return this._validateIdToken(state, response).then(response => {\r\n            return this._validateAccessToken(response);\r\n        });\r\n    }\r\n\r\n    _getSigningKeyForJwt(jwt) {\r\n        return this._metadataService.getSigningKeys().then(keys => {\r\n            const kid = jwt.header.kid;\r\n            if (!keys) {\r\n                Log.error(\"ResponseValidator._validateIdToken: No signing keys from metadata\");\r\n                return Promise.reject(new Error(\"No signing keys from metadata\"));\r\n            }\r\n\r\n            Log.debug(\"ResponseValidator._validateIdToken: Received signing keys\");\r\n            let key;\r\n            if (!kid) {\r\n                keys = this._filterByAlg(keys, jwt.header.alg);\r\n\r\n                if (keys.length > 1) {\r\n                    Log.error(\"ResponseValidator._validateIdToken: No kid found in id_token and more than one key found in metadata\");\r\n                    return Promise.reject(new Error(\"No kid found in id_token and more than one key found in metadata\"));\r\n                } else {\r\n                    // kid is mandatory only when there are multiple keys in the referenced JWK Set document\r\n                    // see http://openid.net/specs/openid-connect-core-1_0.html#Signing\r\n                    key = keys[0];\r\n                }\r\n            } else {\r\n                key = keys.filter(key => {\r\n                    return key.kid === kid;\r\n                })[0];\r\n            }\r\n            return Promise.resolve(key);\r\n        });\r\n    }\r\n\r\n    _getSigningKeyForJwtWithSingleRetry(jwt) {\r\n        return this._getSigningKeyForJwt(jwt).then(key => {\r\n            // Refreshing signingKeys if no suitable verification key is present for given jwt header.\r\n            if (!key) {\r\n                // set to undefined, to trigger network call to jwks_uri.\r\n                this._metadataService.resetSigningKeys();\r\n                return this._getSigningKeyForJwt(jwt);\r\n            } else {\r\n                return Promise.resolve(key);\r\n            }\r\n        });\r\n    }\r\n\r\n    _validateIdToken(state, response) {\r\n        if (!state.nonce) {\r\n            Log.error(\"ResponseValidator._validateIdToken: No nonce on state\");\r\n            return Promise.reject(new Error(\"No nonce on state\"));\r\n        }\r\n\r\n        let jwt = this._joseUtil.parseJwt(response.id_token);\r\n        if (!jwt || !jwt.header || !jwt.payload) {\r\n            Log.error(\"ResponseValidator._validateIdToken: Failed to parse id_token\", jwt);\r\n            return Promise.reject(new Error(\"Failed to parse id_token\"));\r\n        }\r\n\r\n        if (state.nonce !== jwt.payload.nonce) {\r\n            Log.error(\"ResponseValidator._validateIdToken: Invalid nonce in id_token\");\r\n            return Promise.reject(new Error(\"Invalid nonce in id_token\"));\r\n        }\r\n\r\n        return this._metadataService.getIssuer().then(issuer => {\r\n            Log.debug(\"ResponseValidator._validateIdToken: Received issuer\");\r\n            return this._getSigningKeyForJwtWithSingleRetry(jwt).then(key => {\r\n                if (!key) {\r\n                    Log.error(\"ResponseValidator._validateIdToken: No key matching kid or alg found in signing keys\");\r\n                    return Promise.reject(new Error(\"No key matching kid or alg found in signing keys\"));\r\n                }\r\n\r\n                let audience = state.client_id;\r\n\r\n                let clockSkewInSeconds = this._settings.clockSkew;\r\n                Log.debug(\"ResponseValidator._validateIdToken: Validaing JWT; using clock skew (in seconds) of: \", clockSkewInSeconds);\r\n\r\n                return this._joseUtil.validateJwt(response.id_token, key, issuer, audience, clockSkewInSeconds).then(()=>{\r\n                    Log.debug(\"ResponseValidator._validateIdToken: JWT validation successful\");\r\n\r\n                    if (!jwt.payload.sub) {\r\n                        Log.error(\"ResponseValidator._validateIdToken: No sub present in id_token\");\r\n                        return Promise.reject(new Error(\"No sub present in id_token\"));\r\n                    }\r\n\r\n                    response.profile = jwt.payload;\r\n\r\n                    return response;\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    _filterByAlg(keys, alg){\r\n        var kty = null;\r\n        if (alg.startsWith(\"RS\")) {\r\n            kty = \"RSA\";\r\n        }\r\n        else if (alg.startsWith(\"PS\")) {\r\n            kty = \"PS\";\r\n        }\r\n        else if (alg.startsWith(\"ES\")) {\r\n            kty = \"EC\";\r\n        }\r\n        else {\r\n            Log.debug(\"ResponseValidator._filterByAlg: alg not supported: \", alg);\r\n            return [];\r\n        }\r\n\r\n        Log.debug(\"ResponseValidator._filterByAlg: Looking for keys that match kty: \", kty);\r\n\r\n        keys = keys.filter(key => {\r\n            return key.kty === kty;\r\n        });\r\n\r\n        Log.debug(\"ResponseValidator._filterByAlg: Number of keys that match kty: \", kty, keys.length);\r\n\r\n        return keys;\r\n    }\r\n\r\n    _validateAccessToken(response) {\r\n        if (!response.profile) {\r\n            Log.error(\"ResponseValidator._validateAccessToken: No profile loaded from id_token\");\r\n            return Promise.reject(new Error(\"No profile loaded from id_token\"));\r\n        }\r\n\r\n        if (!response.profile.at_hash) {\r\n            Log.error(\"ResponseValidator._validateAccessToken: No at_hash in id_token\");\r\n            return Promise.reject(new Error(\"No at_hash in id_token\"));\r\n        }\r\n\r\n        if (!response.id_token) {\r\n            Log.error(\"ResponseValidator._validateAccessToken: No id_token\");\r\n            return Promise.reject(new Error(\"No id_token\"));\r\n        }\r\n\r\n        let jwt = this._joseUtil.parseJwt(response.id_token);\r\n        if (!jwt || !jwt.header) {\r\n            Log.error(\"ResponseValidator._validateAccessToken: Failed to parse id_token\", jwt);\r\n            return Promise.reject(new Error(\"Failed to parse id_token\"));\r\n        }\r\n\r\n        var hashAlg = jwt.header.alg;\r\n        if (!hashAlg || hashAlg.length !== 5) {\r\n            Log.error(\"ResponseValidator._validateAccessToken: Unsupported alg:\", hashAlg);\r\n            return Promise.reject(new Error(\"Unsupported alg: \" + hashAlg));\r\n        }\r\n\r\n        var hashBits = hashAlg.substr(2, 3);\r\n        if (!hashBits) {\r\n            Log.error(\"ResponseValidator._validateAccessToken: Unsupported alg:\", hashAlg, hashBits);\r\n            return Promise.reject(new Error(\"Unsupported alg: \" + hashAlg));\r\n        }\r\n\r\n        hashBits = parseInt(hashBits);\r\n        if (hashBits !== 256 && hashBits !== 384 && hashBits !== 512) {\r\n            Log.error(\"ResponseValidator._validateAccessToken: Unsupported alg:\", hashAlg, hashBits);\r\n            return Promise.reject(new Error(\"Unsupported alg: \" + hashAlg));\r\n        }\r\n\r\n        let sha = \"sha\" + hashBits;\r\n        var hash = this._joseUtil.hashString(response.access_token, sha);\r\n        if (!hash) {\r\n            Log.error(\"ResponseValidator._validateAccessToken: access_token hash failed:\", sha);\r\n            return Promise.reject(new Error(\"Failed to validate at_hash\"));\r\n        }\r\n\r\n        var left = hash.substr(0, hash.length / 2);\r\n        var left_b64u = this._joseUtil.hexToBase64Url(left);\r\n        if (left_b64u !== response.profile.at_hash) {\r\n            Log.error(\"ResponseValidator._validateAccessToken: Failed to validate at_hash\", left_b64u, response.profile.at_hash);\r\n            return Promise.reject(new Error(\"Failed to validate at_hash\"));\r\n        }\r\n\r\n        Log.debug(\"ResponseValidator._validateAccessToken: success\");\r\n\r\n        return Promise.resolve(response);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}