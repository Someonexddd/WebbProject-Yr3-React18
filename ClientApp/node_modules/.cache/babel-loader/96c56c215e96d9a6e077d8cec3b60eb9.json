{"ast":null,"code":"// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\nimport { Log } from './Log.js';\nimport { Timer } from './Timer.js';\nconst DefaultAccessTokenExpiringNotificationTime = 60; // seconds\n\nexport class AccessTokenEvents {\n  constructor() {\n    let {\n      accessTokenExpiringNotificationTime = DefaultAccessTokenExpiringNotificationTime,\n      accessTokenExpiringTimer = new Timer(\"Access token expiring\"),\n      accessTokenExpiredTimer = new Timer(\"Access token expired\")\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._accessTokenExpiringNotificationTime = accessTokenExpiringNotificationTime;\n    this._accessTokenExpiring = accessTokenExpiringTimer;\n    this._accessTokenExpired = accessTokenExpiredTimer;\n  }\n\n  load(container) {\n    // only register events if there's an access token and it has an expiration\n    if (container.access_token && container.expires_in !== undefined) {\n      let duration = container.expires_in;\n      Log.debug(\"AccessTokenEvents.load: access token present, remaining duration:\", duration);\n\n      if (duration > 0) {\n        // only register expiring if we still have time\n        let expiring = duration - this._accessTokenExpiringNotificationTime;\n\n        if (expiring <= 0) {\n          expiring = 1;\n        }\n\n        Log.debug(\"AccessTokenEvents.load: registering expiring timer in:\", expiring);\n\n        this._accessTokenExpiring.init(expiring);\n      } else {\n        Log.debug(\"AccessTokenEvents.load: canceling existing expiring timer becase we're past expiration.\");\n\n        this._accessTokenExpiring.cancel();\n      } // if it's negative, it will still fire\n\n\n      let expired = duration + 1;\n      Log.debug(\"AccessTokenEvents.load: registering expired timer in:\", expired);\n\n      this._accessTokenExpired.init(expired);\n    } else {\n      this._accessTokenExpiring.cancel();\n\n      this._accessTokenExpired.cancel();\n    }\n  }\n\n  unload() {\n    Log.debug(\"AccessTokenEvents.unload: canceling existing access token timers\");\n\n    this._accessTokenExpiring.cancel();\n\n    this._accessTokenExpired.cancel();\n  }\n\n  addAccessTokenExpiring(cb) {\n    this._accessTokenExpiring.addHandler(cb);\n  }\n\n  removeAccessTokenExpiring(cb) {\n    this._accessTokenExpiring.removeHandler(cb);\n  }\n\n  addAccessTokenExpired(cb) {\n    this._accessTokenExpired.addHandler(cb);\n  }\n\n  removeAccessTokenExpired(cb) {\n    this._accessTokenExpired.removeHandler(cb);\n  }\n\n}","map":{"version":3,"names":["Log","Timer","DefaultAccessTokenExpiringNotificationTime","AccessTokenEvents","constructor","accessTokenExpiringNotificationTime","accessTokenExpiringTimer","accessTokenExpiredTimer","_accessTokenExpiringNotificationTime","_accessTokenExpiring","_accessTokenExpired","load","container","access_token","expires_in","undefined","duration","debug","expiring","init","cancel","expired","unload","addAccessTokenExpiring","cb","addHandler","removeAccessTokenExpiring","removeHandler","addAccessTokenExpired","removeAccessTokenExpired"],"sources":["C:/Users/theoj/Desktop/WebbProject-Yr3-React18/ClientApp/node_modules/oidc-client/src/AccessTokenEvents.js"],"sourcesContent":["// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\r\n\r\nimport { Log } from './Log.js';\r\nimport { Timer } from './Timer.js';\r\n\r\nconst DefaultAccessTokenExpiringNotificationTime = 60; // seconds\r\n\r\nexport class AccessTokenEvents {\r\n\r\n    constructor({\r\n        accessTokenExpiringNotificationTime = DefaultAccessTokenExpiringNotificationTime,\r\n        accessTokenExpiringTimer = new Timer(\"Access token expiring\"),\r\n        accessTokenExpiredTimer = new Timer(\"Access token expired\")\r\n    } = {}) {\r\n        this._accessTokenExpiringNotificationTime = accessTokenExpiringNotificationTime;\r\n\r\n        this._accessTokenExpiring = accessTokenExpiringTimer;\r\n        this._accessTokenExpired = accessTokenExpiredTimer;\r\n    }\r\n\r\n    load(container) {\r\n        // only register events if there's an access token and it has an expiration\r\n        if (container.access_token && container.expires_in !== undefined) {\r\n            let duration = container.expires_in;\r\n            Log.debug(\"AccessTokenEvents.load: access token present, remaining duration:\", duration);\r\n\r\n            if (duration > 0) {\r\n                // only register expiring if we still have time\r\n                let expiring = duration - this._accessTokenExpiringNotificationTime;\r\n                if (expiring <= 0){\r\n                    expiring = 1;\r\n                }\r\n                \r\n                Log.debug(\"AccessTokenEvents.load: registering expiring timer in:\", expiring);\r\n                this._accessTokenExpiring.init(expiring);\r\n            }\r\n            else {\r\n                Log.debug(\"AccessTokenEvents.load: canceling existing expiring timer becase we're past expiration.\");\r\n                this._accessTokenExpiring.cancel();\r\n            }\r\n\r\n            // if it's negative, it will still fire\r\n            let expired = duration + 1;\r\n            Log.debug(\"AccessTokenEvents.load: registering expired timer in:\", expired);\r\n            this._accessTokenExpired.init(expired);\r\n        }\r\n        else {\r\n            this._accessTokenExpiring.cancel();\r\n            this._accessTokenExpired.cancel();\r\n        }\r\n    }\r\n\r\n    unload() {\r\n        Log.debug(\"AccessTokenEvents.unload: canceling existing access token timers\");\r\n        this._accessTokenExpiring.cancel();\r\n        this._accessTokenExpired.cancel();\r\n    }\r\n\r\n    addAccessTokenExpiring(cb) {\r\n        this._accessTokenExpiring.addHandler(cb);\r\n    }\r\n    removeAccessTokenExpiring(cb) {\r\n        this._accessTokenExpiring.removeHandler(cb);\r\n    }\r\n\r\n    addAccessTokenExpired(cb) {\r\n        this._accessTokenExpired.addHandler(cb);\r\n    }\r\n    removeAccessTokenExpired(cb) {\r\n        this._accessTokenExpired.removeHandler(cb);\r\n    }\r\n}\r\n"],"mappings":"AAAA;AACA;AAEA,SAASA,GAAT,QAAoB,UAApB;AACA,SAASC,KAAT,QAAsB,YAAtB;AAEA,MAAMC,0CAA0C,GAAG,EAAnD,C,CAAuD;;AAEvD,OAAO,MAAMC,iBAAN,CAAwB;EAE3BC,WAAW,GAIH;IAAA,IAJI;MACRC,mCAAmC,GAAGH,0CAD9B;MAERI,wBAAwB,GAAG,IAAIL,KAAJ,CAAU,uBAAV,CAFnB;MAGRM,uBAAuB,GAAG,IAAIN,KAAJ,CAAU,sBAAV;IAHlB,CAIJ,uEAAJ,EAAI;IACJ,KAAKO,oCAAL,GAA4CH,mCAA5C;IAEA,KAAKI,oBAAL,GAA4BH,wBAA5B;IACA,KAAKI,mBAAL,GAA2BH,uBAA3B;EACH;;EAEDI,IAAI,CAACC,SAAD,EAAY;IACZ;IACA,IAAIA,SAAS,CAACC,YAAV,IAA0BD,SAAS,CAACE,UAAV,KAAyBC,SAAvD,EAAkE;MAC9D,IAAIC,QAAQ,GAAGJ,SAAS,CAACE,UAAzB;MACAd,GAAG,CAACiB,KAAJ,CAAU,mEAAV,EAA+ED,QAA/E;;MAEA,IAAIA,QAAQ,GAAG,CAAf,EAAkB;QACd;QACA,IAAIE,QAAQ,GAAGF,QAAQ,GAAG,KAAKR,oCAA/B;;QACA,IAAIU,QAAQ,IAAI,CAAhB,EAAkB;UACdA,QAAQ,GAAG,CAAX;QACH;;QAEDlB,GAAG,CAACiB,KAAJ,CAAU,wDAAV,EAAoEC,QAApE;;QACA,KAAKT,oBAAL,CAA0BU,IAA1B,CAA+BD,QAA/B;MACH,CATD,MAUK;QACDlB,GAAG,CAACiB,KAAJ,CAAU,yFAAV;;QACA,KAAKR,oBAAL,CAA0BW,MAA1B;MACH,CAjB6D,CAmB9D;;;MACA,IAAIC,OAAO,GAAGL,QAAQ,GAAG,CAAzB;MACAhB,GAAG,CAACiB,KAAJ,CAAU,uDAAV,EAAmEI,OAAnE;;MACA,KAAKX,mBAAL,CAAyBS,IAAzB,CAA8BE,OAA9B;IACH,CAvBD,MAwBK;MACD,KAAKZ,oBAAL,CAA0BW,MAA1B;;MACA,KAAKV,mBAAL,CAAyBU,MAAzB;IACH;EACJ;;EAEDE,MAAM,GAAG;IACLtB,GAAG,CAACiB,KAAJ,CAAU,kEAAV;;IACA,KAAKR,oBAAL,CAA0BW,MAA1B;;IACA,KAAKV,mBAAL,CAAyBU,MAAzB;EACH;;EAEDG,sBAAsB,CAACC,EAAD,EAAK;IACvB,KAAKf,oBAAL,CAA0BgB,UAA1B,CAAqCD,EAArC;EACH;;EACDE,yBAAyB,CAACF,EAAD,EAAK;IAC1B,KAAKf,oBAAL,CAA0BkB,aAA1B,CAAwCH,EAAxC;EACH;;EAEDI,qBAAqB,CAACJ,EAAD,EAAK;IACtB,KAAKd,mBAAL,CAAyBe,UAAzB,CAAoCD,EAApC;EACH;;EACDK,wBAAwB,CAACL,EAAD,EAAK;IACzB,KAAKd,mBAAL,CAAyBiB,aAAzB,CAAuCH,EAAvC;EACH;;AA/D0B"},"metadata":{},"sourceType":"module"}