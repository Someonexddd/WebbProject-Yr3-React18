{"ast":null,"code":"// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\nimport { JsonService } from './JsonService.js';\nimport { MetadataService } from './MetadataService.js';\nimport { Log } from './Log.js';\nimport { JoseUtil } from './JoseUtil.js';\nexport class UserInfoService {\n  constructor(settings) {\n    let JsonServiceCtor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : JsonService;\n    let MetadataServiceCtor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MetadataService;\n    let joseUtil = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : JoseUtil;\n\n    if (!settings) {\n      Log.error(\"UserInfoService.ctor: No settings passed\");\n      throw new Error(\"settings\");\n    }\n\n    this._settings = settings;\n    this._jsonService = new JsonServiceCtor(undefined, undefined, this._getClaimsFromJwt.bind(this));\n    this._metadataService = new MetadataServiceCtor(this._settings);\n    this._joseUtil = joseUtil;\n  }\n\n  getClaims(token) {\n    if (!token) {\n      Log.error(\"UserInfoService.getClaims: No token passed\");\n      return Promise.reject(new Error(\"A token is required\"));\n    }\n\n    return this._metadataService.getUserInfoEndpoint().then(url => {\n      Log.debug(\"UserInfoService.getClaims: received userinfo url\", url);\n      return this._jsonService.getJson(url, token).then(claims => {\n        Log.debug(\"UserInfoService.getClaims: claims received\", claims);\n        return claims;\n      });\n    });\n  }\n\n  _getClaimsFromJwt(req) {\n    try {\n      let jwt = this._joseUtil.parseJwt(req.responseText);\n\n      if (!jwt || !jwt.header || !jwt.payload) {\n        Log.error(\"UserInfoService._getClaimsFromJwt: Failed to parse JWT\", jwt);\n        return Promise.reject(new Error(\"Failed to parse id_token\"));\n      }\n\n      var kid = jwt.header.kid;\n      let issuerPromise;\n\n      switch (this._settings.userInfoJwtIssuer) {\n        case 'OP':\n          issuerPromise = this._metadataService.getIssuer();\n          break;\n\n        case 'ANY':\n          issuerPromise = Promise.resolve(jwt.payload.iss);\n          break;\n\n        default:\n          issuerPromise = Promise.resolve(this._settings.userInfoJwtIssuer);\n          break;\n      }\n\n      return issuerPromise.then(issuer => {\n        Log.debug(\"UserInfoService._getClaimsFromJwt: Received issuer:\" + issuer);\n        return this._metadataService.getSigningKeys().then(keys => {\n          if (!keys) {\n            Log.error(\"UserInfoService._getClaimsFromJwt: No signing keys from metadata\");\n            return Promise.reject(new Error(\"No signing keys from metadata\"));\n          }\n\n          Log.debug(\"UserInfoService._getClaimsFromJwt: Received signing keys\");\n          let key;\n\n          if (!kid) {\n            keys = this._filterByAlg(keys, jwt.header.alg);\n\n            if (keys.length > 1) {\n              Log.error(\"UserInfoService._getClaimsFromJwt: No kid found in id_token and more than one key found in metadata\");\n              return Promise.reject(new Error(\"No kid found in id_token and more than one key found in metadata\"));\n            } else {\n              // kid is mandatory only when there are multiple keys in the referenced JWK Set document\n              // see http://openid.net/specs/openid-connect-core-1_0.html#Signing\n              key = keys[0];\n            }\n          } else {\n            key = keys.filter(key => {\n              return key.kid === kid;\n            })[0];\n          }\n\n          if (!key) {\n            Log.error(\"UserInfoService._getClaimsFromJwt: No key matching kid or alg found in signing keys\");\n            return Promise.reject(new Error(\"No key matching kid or alg found in signing keys\"));\n          }\n\n          let audience = this._settings.client_id;\n          let clockSkewInSeconds = this._settings.clockSkew;\n          Log.debug(\"UserInfoService._getClaimsFromJwt: Validaing JWT; using clock skew (in seconds) of: \", clockSkewInSeconds);\n          return this._joseUtil.validateJwt(req.responseText, key, issuer, audience, clockSkewInSeconds, undefined, true).then(() => {\n            Log.debug(\"UserInfoService._getClaimsFromJwt: JWT validation successful\");\n            return jwt.payload;\n          });\n        });\n      });\n      return;\n    } catch (e) {\n      Log.error(\"UserInfoService._getClaimsFromJwt: Error parsing JWT response\", e.message);\n      reject(e);\n      return;\n    }\n  }\n\n  _filterByAlg(keys, alg) {\n    var kty = null;\n\n    if (alg.startsWith(\"RS\")) {\n      kty = \"RSA\";\n    } else if (alg.startsWith(\"PS\")) {\n      kty = \"PS\";\n    } else if (alg.startsWith(\"ES\")) {\n      kty = \"EC\";\n    } else {\n      Log.debug(\"UserInfoService._filterByAlg: alg not supported: \", alg);\n      return [];\n    }\n\n    Log.debug(\"UserInfoService._filterByAlg: Looking for keys that match kty: \", kty);\n    keys = keys.filter(key => {\n      return key.kty === kty;\n    });\n    Log.debug(\"UserInfoService._filterByAlg: Number of keys that match kty: \", kty, keys.length);\n    return keys;\n  }\n\n}","map":{"version":3,"names":["JsonService","MetadataService","Log","JoseUtil","UserInfoService","constructor","settings","JsonServiceCtor","MetadataServiceCtor","joseUtil","error","Error","_settings","_jsonService","undefined","_getClaimsFromJwt","bind","_metadataService","_joseUtil","getClaims","token","Promise","reject","getUserInfoEndpoint","then","url","debug","getJson","claims","req","jwt","parseJwt","responseText","header","payload","kid","issuerPromise","userInfoJwtIssuer","getIssuer","resolve","iss","issuer","getSigningKeys","keys","key","_filterByAlg","alg","length","filter","audience","client_id","clockSkewInSeconds","clockSkew","validateJwt","e","message","kty","startsWith"],"sources":["C:/Users/theoj/Desktop/WebbProject-Yr3-React18/ClientApp/node_modules/oidc-client/src/UserInfoService.js"],"sourcesContent":["// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\r\n\r\nimport { JsonService } from './JsonService.js';\r\nimport { MetadataService } from './MetadataService.js';\r\nimport { Log } from './Log.js';\r\nimport { JoseUtil } from './JoseUtil.js';\r\n\r\nexport class UserInfoService {\r\n    constructor(\r\n        settings, \r\n        JsonServiceCtor = JsonService, \r\n        MetadataServiceCtor = MetadataService, \r\n        joseUtil = JoseUtil\r\n    ) {\r\n        if (!settings) {\r\n            Log.error(\"UserInfoService.ctor: No settings passed\");\r\n            throw new Error(\"settings\");\r\n        }\r\n\r\n        this._settings = settings;\r\n        this._jsonService = new JsonServiceCtor(undefined, undefined, this._getClaimsFromJwt.bind(this));\r\n        this._metadataService = new MetadataServiceCtor(this._settings);\r\n        this._joseUtil = joseUtil;\r\n    }\r\n\r\n    getClaims(token) {\r\n        if (!token) {\r\n            Log.error(\"UserInfoService.getClaims: No token passed\");\r\n            return Promise.reject(new Error(\"A token is required\"));\r\n        }\r\n\r\n        return this._metadataService.getUserInfoEndpoint().then(url => {\r\n            Log.debug(\"UserInfoService.getClaims: received userinfo url\", url);\r\n\r\n            return this._jsonService.getJson(url, token).then(claims => {\r\n                Log.debug(\"UserInfoService.getClaims: claims received\", claims);\r\n                return claims;\r\n            });\r\n        });\r\n    }\r\n\r\n    _getClaimsFromJwt(req) {\r\n        try {\r\n            let jwt = this._joseUtil.parseJwt(req.responseText);\r\n            if (!jwt || !jwt.header || !jwt.payload) {\r\n                Log.error(\"UserInfoService._getClaimsFromJwt: Failed to parse JWT\", jwt);\r\n                return Promise.reject(new Error(\"Failed to parse id_token\"));\r\n            }\r\n\r\n            var kid = jwt.header.kid;\r\n\r\n            let issuerPromise;\r\n            switch (this._settings.userInfoJwtIssuer) {\r\n                case 'OP':\r\n                    issuerPromise = this._metadataService.getIssuer();\r\n                    break;\r\n                case 'ANY':\r\n                    issuerPromise = Promise.resolve(jwt.payload.iss);\r\n                    break;\r\n                default:\r\n                    issuerPromise = Promise.resolve(this._settings.userInfoJwtIssuer);\r\n                    break;\r\n            }\r\n\r\n            return issuerPromise.then(issuer => {\r\n                Log.debug(\"UserInfoService._getClaimsFromJwt: Received issuer:\" + issuer);\r\n\r\n                return this._metadataService.getSigningKeys().then(keys => {\r\n                    if (!keys) {\r\n                        Log.error(\"UserInfoService._getClaimsFromJwt: No signing keys from metadata\");\r\n                        return Promise.reject(new Error(\"No signing keys from metadata\"));\r\n                    }\r\n\r\n                    Log.debug(\"UserInfoService._getClaimsFromJwt: Received signing keys\");\r\n                    let key;\r\n                    if (!kid) {\r\n                        keys = this._filterByAlg(keys, jwt.header.alg);\r\n\r\n                        if (keys.length > 1) {\r\n                            Log.error(\"UserInfoService._getClaimsFromJwt: No kid found in id_token and more than one key found in metadata\");\r\n                            return Promise.reject(new Error(\"No kid found in id_token and more than one key found in metadata\"));\r\n                        }\r\n                        else {\r\n                            // kid is mandatory only when there are multiple keys in the referenced JWK Set document\r\n                            // see http://openid.net/specs/openid-connect-core-1_0.html#Signing\r\n                            key = keys[0];\r\n                        }\r\n                    }\r\n                    else {\r\n                        key = keys.filter(key => {\r\n                            return key.kid === kid;\r\n                        })[0];\r\n                    }\r\n\r\n                    if (!key) {\r\n                        Log.error(\"UserInfoService._getClaimsFromJwt: No key matching kid or alg found in signing keys\");\r\n                        return Promise.reject(new Error(\"No key matching kid or alg found in signing keys\"));\r\n                    }\r\n\r\n                    let audience = this._settings.client_id;\r\n\r\n                    let clockSkewInSeconds = this._settings.clockSkew;\r\n                    Log.debug(\"UserInfoService._getClaimsFromJwt: Validaing JWT; using clock skew (in seconds) of: \", clockSkewInSeconds);\r\n\r\n                    return this._joseUtil.validateJwt(req.responseText, key, issuer, audience, clockSkewInSeconds, undefined, true).then(() => {\r\n                        Log.debug(\"UserInfoService._getClaimsFromJwt: JWT validation successful\");\r\n                        return jwt.payload;\r\n                    });\r\n                });\r\n            });\r\n            return;\r\n        }\r\n        catch (e) {\r\n            Log.error(\"UserInfoService._getClaimsFromJwt: Error parsing JWT response\", e.message);\r\n            reject(e);\r\n            return;\r\n        }\r\n    }\r\n\r\n    _filterByAlg(keys, alg) {\r\n        var kty = null;\r\n        if (alg.startsWith(\"RS\")) {\r\n            kty = \"RSA\";\r\n        }\r\n        else if (alg.startsWith(\"PS\")) {\r\n            kty = \"PS\";\r\n        }\r\n        else if (alg.startsWith(\"ES\")) {\r\n            kty = \"EC\";\r\n        }\r\n        else {\r\n            Log.debug(\"UserInfoService._filterByAlg: alg not supported: \", alg);\r\n            return [];\r\n        }\r\n\r\n        Log.debug(\"UserInfoService._filterByAlg: Looking for keys that match kty: \", kty);\r\n\r\n        keys = keys.filter(key => {\r\n            return key.kty === kty;\r\n        });\r\n\r\n        Log.debug(\"UserInfoService._filterByAlg: Number of keys that match kty: \", kty, keys.length);\r\n\r\n        return keys;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}